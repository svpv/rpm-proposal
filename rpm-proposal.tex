\documentclass[russian,a4paper,12pt,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{fullpage}
\usepackage{url}

\sloppy
\hyphenpenalty=666

\begin{document}
\title{Предложения по развитию\\системы управления пакетами RPM}
\author{Алексей Турбин \url{<at@altlinux.org>}}
\maketitle
\tableofcontents
\pagebreak[4]

\section*{Введение}
Ян Мёрдок (основатель проекта Debian) назвал управление пакетами <<самым
выдающимся достижением, которое Linux привнес в IT-отрасль>>.\footnote{\textit{The
single biggest advancement Linux has brought to the industry.}
\url{http://ianmurdock.com/solaris/how-package-management-changed-everything/}}
Мёрдок отмечает, в частности, возможность унифицированного обновления ПО по сети,
а также модель распределенной разработки, которая стала возможна благодаря разбиению
операционной системы на компоненты.

Нужно заметить, однако, что возможность обновления пакетов по сети
реализуется в виде надстройки (apt, yum) над базовым уровнем управления пакетами
(rpm, deb), тогда как модель распределенной разработки является не столько техническим,
сколько социальным аспектом разработки свободного ПО.  В то же время функции, реализуемые
на базовом уровне управления пакетами, подозрительно похожи на функции архиватора типа tar,
который существовал в UNIX всегда.
Действительно, rpm-пакеты можно рассматривать как <<тарболлы>>, а rpm~--- как
некоторое подобие tar (по крайней мере, в части установки пакетов).  Более того,
в некоторых системах <<тарболл>> и является основным форматом пакетов.  Возникает
вопрос: каковы главные особенности системы управления пакетами на базовом уровне,
делающие ее принципиально отличной от архиватора?  Что можно считать
<<достижением>> на базовом уровне?

На первый взгляд, главным отличием rpm от архиватора является возможность обновления и удаления пакетов.
В отличие от обычного архиватора, rpm поддерживает базу пакетов \verb|rpmdb|, в которой хранится информация
об установленных пакетах и о файлах, ассоциированных с пакетами.  При обновлении пакетов эта информация
позволяет корректно выполнить замещение файлов и т.\,п.  Впрочем, нужно понимать, что некоторая сложность,
связанная с корректным замещением файлов, возникает вследствие использования традиционной иерархии файловой
системы, при которой файлы в зависимости от их назначения располагаются в разных системных каталогах.
Некоторые разработчики считают традиционную иерархию файловой системы слишком сложной.
Так, в дистрибутиве GoboLinux выполнена полная реорганизация файловой системы: каждому пакету отводится
собственный подкаталог в системном каталоге \verb|/Programs|.  Это радикально упрощает обновление пакетов,
сводя его к удалению старого каталога и распаковке нового архива.

На наш взгляд, принципальное отличие управления пакетами от <<управления тарболлами>> состоит в другом.
Архиватору безразлично содержимое файлов в архиве, распаковка~--- это его единственная функция; сохранность
байтов~--- это всё, что его в принципе интересует.  В то же время перед rpm стоит более сложная задача:
поддержка операционной системы в целостном, согласованном состоянии.  Фактически, базовый уровень
управления пакетами должен гарантировать работоспособность операционной системы (в той степени,
в которой это вообще возможно) и обеспечивать совместимость установленных компонентов ПО.  Возможность
обновления ПО по сети, отмеченную Мёрдоком, можно интерпретировать именно так~--- как поддержку ОС
в актуальном рабочем состоянии.

Таким образом, можно сказать, что базовый уровень управления пакетами является <<достижением>> настолько,
насколько он \textit{не сводится} к функциям архиватора.  В частности, в какой-то момент система управления
пакетами должна весьма сильно интересоваться содержимым файлов, входящих в пакет, т.\,к. работоспособность
операционной системы и совместимость компонентов ПО могут быть во многих случаях объяснены в терминах
содержимого тех или иных файлов.  Если же не интересоваться содержимым файлов, то гарантировать их согласованную
совместную работу, по-видимому, никак нельзя.

В rpm основным способом описания работоспособности и совместимости пакетов являются \textit{зависимости}.
При сборке пакетов rpm изучает содержимое файлов, входящих в пакет, и формирует зависимости пакета.
Зависимости Requires описывают требования, которые предъявляются к другим пакетам.  Зависимости Provides
в свою очередь описывают <<предоставляемые>> свойства пакета, которые могуть быть <<затребованы>> через
Requires в других пакетах.  Соответственно, в rpm имеются вспомогательные программы \verb|find-requires|
и \verb|find-provides|, которые выполняют поиск Requires и Provides зависимостей.  Эти две программы
составляют основу \textit{подсистемы автоматического поиска зависимостей} (эта подсистема также может быть
использована для автоматического поиска зависимостей типа \verb|Reqires(post)| в \%post-скриптах,
о чем подробнее в разделе \ref{post-script-deps}).  Большая часть данного документа посвящена
усовершенствованию этой подсистемы.  Как будет видно в дальнейшем, многие требования работоспособности
и совместимости пакетов могут быть описаны гораздо более точно.  Так, в разделе \ref{set-versions} описан
способ компактного представления множества символов, с помощью которого можно в значительной степени
решить проблему т.\,н. <<dll hell>>~--- проблему версионирования и неполной совместимости разделяемых библиотек.

Интересно отметить <<асимметричный>> характер системы управления пакетами на базовом уровне: содержимое
файлов изучается только во время сборки пакетов для формирования зависимостей.  На стадии же установки
rpm руководствуется зависимостями, полученными при сборке; а содержимое файлов его снова не интересует.
В терминах дихотомии Эрика Реймонда\footnote{\textit{Rule of Separation: Separate policy from mechanism;
separate interfaces from engines.} \url{http://www.faqs.org/docs/artu/ch01s06.html}}
можно сказать, что при установке пакетов работает базовый \textit{механизм}, тогда как \textit{политика}
управления пакетами на самом деле осуществляется во время сборки.

Политика сборки пакетов не обязательно должна ограничиваться анализом файлов для формирования зависимостей.
Можно реализовать более агрессивную политику сборки, направленную, во-первых, на автоматическую коррекцию содержимого
пакетов, а во-вторых, на автоматическую верификцию, которая должна быть выполнена, чтобы пакет успешно собрался.
Процедуры верификации могут выполняться, в частности, на стадии brp (buildroot policy).  Примером коррекции содержимого
пакетов является процедура brp-debuginfo, которая используется для подготовки пакетов с отладочной информацией (см. раздел
\ref{debuginfo-subpackages}).  Некоторые процедуры автоматической верификции рассмотрены в разделе \ref{brp-verify}.

Однако не все проверки стоит выполнять при сборке пакета.  Некоторые проверки
являются специфическими для дистрибутива и поэтому не могут быть частью базовой
политики сборки пакета (например, сюда можно отнести формальное требование указывать
в \%changelog <<официальный>> e-mail адрес, связанный с проектом).  Другие проверки не требуют
доступа к содержимому файлов~--- например, проверка путей на соответствие FHS (filesystem hierarchy standard).
Другой пример: архитектурно-независимые пакеты (noarch) не должны содержать архитектурно-зависимых путей
(файлов в каталоге \verb|/usr/lib64| и подкаталогах).  Такие проверки можно оформить в виде отдельной программы
типа rpmlint.

Между прочим, последняя проверка является во многих отношениях недостаточной: в noarch пакетах не только не должно быть
архитектурно-зависимых путей, но и вообще при сборке на любой архитектуре должны получаться \emph{идентичные} noarch пакеты.
Таким образом, выполнение такой проверки потребует синхронной сборки пакета на двух (или более) архитектурах, т.е.
она не может быть реализована на уровне rpm, а только на уровне сборочной системы (если сборочная система синхронизирует
сборку для нескольких архитектур).  В сборочной системе одного российского дистрибутива реализована именно такая~--- достаточно
строгая~--- политика верификации noarch пакетов.

Мы завершаем введение кратким обзором сборочной системы.\footnote{Подробнее см. \textit{Сборочная система git.alt}
в сборнике \url{http://www.altlinux.ru/media/book-thesis-Protva-2008-5.pdf}}  Приоритетной задачей сборочной системы
является автоматическое тестирование и верификация пакетов во время и после сборки, т.\,е. политика сборки, направленная
на поддержку целостности репозитория пакетов (в то время как, например, наличие веб-интерфейса для нас не представляет интереса).
Сборочная система характеризуется относительно высоким процентом отказов в приеме пакетов (при обнаружении дефектов в пакетах).
В то же время сборочная система работает полностью автоматически, и пакеты без дефектов поступают в репозиторий сразу же (проверка
вручную и дополнительное тестирование могут быть организованы перед публикацией репозитория на официальном сервере).

Политику сборочной системы можно описать в терминах \textit{формальной модели}: поступление новых пакетов моделируется
как переход репозитория из состояния $A_0$ в состояние $A_1$.  При этом, в идеале, в любом состоянии должно быть выполнено
формальное условие, которое можно назвать \textit{инвариантом перехода}: все пакеты должны успешно проходить тестовую пересборку,
и все пакеты должны успешно устанавливаться в базовую среду (basesystem).  В реальности контролировать инвариант перехода
удается лишь частично, т.\,к. тестовая пересборка всех пакетов требует довольно много вычислительных ресурсов.
Как следствие, нереализованной остается принципиально важный компонент сборочной системы~--- \textit{метарепозиторий},
который позволил бы учитывать взаимное влияние между пакетами и, в частности, контролировать изменение свойств пакета
после тестовой пересборки (а не только сам факт пересобираемости).

Интерфейс сборочной системы позволяет формировать \textit{задания} на сборку.  Задание может содержать несколько
пакетов, которые собираются в строгой последовательности (без изменения основного репозитория).  После этого моделируется
переход $A_0\to A_1$ и, если переход разрешен, задание \textit{транзакционно} применяется к репозиторию.  Таким образом,
сборочная система позволяет проводить несовместимые изменения~--- такие, как изменение soname библиотеки~--- при условии
синхронной пересборки (в этом же задании) всех несовместимых/зависимых пакетов.

К недостаткам сборочной системы можно отнести некоторые ограничения на возможность параллельной сборки,
т.\,к. параллельные переходы не моделируются.

\section{Раскрытие макросов в спекфайле}
\textit{Макросы} в rpm являются базовым механизмом параметризации.  С помощью
макросов можно задать как простейшие текстовые подстановки, так и более сложные
(в том числе рекурсивные) подстановки с аргументами.  В спекфайле <<вызов>> макроса
выполняется с помощью конструкций \verb|%{name}|, \verb|%{name args}| или (в сокращенной записи)
\verb|%name|, \verb|%name args|.

Однако использование макросов сопряжено с некоторой опасностью: когда rpm встречает неизвестный макрос
(т.\,е. одну из конструкций указанного вида, в которой макрос с именем \verb|name| не был заранее определен),
rpm оставляет макрос <<нераскрытым>> (т.\,е. сохраняет конструкцию в незименном виде, как если бы она не считалась
<<вызовом>> макроса).  При этом rpm не выводит предупреждений, с помощью которых можно было бы обнаружить
нераскрытые макросы.  Это порождает целый класс ошибок в пакетах.

Например, в пакете \verb|gnumeric-1.10.17-1-mdv2012.0.x86_64.rpm| содержится следующий \%preun-скрипт:
\begin{verbatim}
SCHEMAS=""
for SCHEMA in %schemas ; do
  SCHEMAS="$SCHEMAS /etc/gconf/schemas/$SCHEMA.schemas"
done
GCONF_CONFIG_SOURCE=`/usr/bin/gconftool-2 --get-default-source` \
/usr/bin/gconftool-2 --makefile-uninstall-rule $SCHEMAS >/dev/null || true
\end{verbatim}
Макрос \verb|%schemas| в этом скрипте остался нераскрытым.  Т.\,к. \%preun-скрипт
выполняется при удалении пакета, то при удалении будет выполнен вызов \verb|gconftool-2|
с неправильными аргументами, который должен завершиться с ошибкой (однако эта ошибка игнорируется
с помощью конструкции \texttt{>/dev/null || true}).

Другой пример: в пакете \verb|stardict-3.0.1-10-mdv2011.0.x86_64.rpm| имеется \%preun-скрипт
\begin{verbatim}
%preun_install_gconf_schemas stardict
\end{verbatim}
При удалении такого пакета возникнет ошибка типа \texttt{fg: no job control} или \texttt{fg: no such job},
т.\,к. интерпретатор \verb|/bin/sh| считает такую синтаксическую конструкцию обращением к фоновому заданию.

Ещё один пример: пакет \verb|squid-3.1.16-1-mdv2012.0.x86_64.rpm| содержит \%postun-скрипт
\begin{verbatim}
/usr/share/rpm-helper/del-user squid $1 squid
%post cachemgr
%postun cachemgr
\end{verbatim}
Природа ошибки в данном случае более тонкая~--- эта ошибка не сводится к простому <<человеческому фактору>>,
к которому можно отнести опечатки в названиях макросов или <<забытые>> макросы.

Таким образом, чтобы обнаружить целый класс ошибок и повысить надежность сборки пакетов, мы считаем принципильно
важным диагностировать (в том или ином виде) нераскрытые макросы во время сборки.  В дальнейшем также будет показано, что
определения многих макросов, специфичных для некоторой группы пакетов, могут быть вынесены в отдельный файл и находиться
в отдельном пакете (см. раздел \ref{def-macro-files}).  Это открывает еще одну возможность для появления нераскрытых
макросов: нераскрытые макросы могут появиться из-за нарушения зависимостей или вследствие недостаточных \verb|BuildRequires|
зависимостей у пакетов.  Поэтому, прежде чем выносить определения макросов в отдельные файлы, необходимо реализовать защиту от ошибок,
к которым это может привести.

Некоторая сложность в реализации проверки на нераскрытые макросы связана с тем, что rpm не делает специального различия
между <<ключевыми словами>> и сокращенной записью макросов (например, rpm позволяет определить макрос с именем \verb|build|,
в результате чего будет нарушена структура спекфайла~--- исчезнет секция \verb|%build|).  Кроме того, некоторые <<ключевые слова>>
являются специфичными для отдельных секций спекфайла (например, атрибут \verb|%ghost| используется только в секции \verb|%files|).
Поэтому в текущей реализации проверка выполняется немного по-разному в зависимости от секции спекфайла (проверка реализована
на уровне функции \verb|parseSpec|).

Как уже было сказано, если определения макросов, используемых в спекфайле, содержатся в отдельном пакете,
то в спекфайл должна быть добавлена зависимость \verb|BuildRequires| на этот пакет.  Однако, чтобы извлечь эту зависимость,
нужно распарсить спекфайл, который содержит нераскрытые макросы.  Поэтому желательно реализовать два режима
проверки: строгий и мягкий.  В \textit{строгом} режиме работа rpm завершается с ошибкой, если нераскрытые макросы обнаружены
по крайней мере в некоторых секциях спекфайла (таких как \%post-скрипты).  Строгий режим используется по умолчанию при сборке пакета.
В \textit{мягком} режиме ошибки заменяются на предупреждения, что позволяет распарсить спекфал и извлечь зависимости.

\section{Оптимизация зависимостей}
\label{deps-optimization}
Большая часть предложений в данном документе направлена на совершенствование зависимостей у пакетов;
в том числе предполагается реализация новых типов зависимостей.  Зависимостей станет много.  Это не только
увеличивает размер пакетов, но и повышает нагрузку на сборочную систему, увеличивает время, необходимое
для проверки зависимостей при установке пакетов и т.\,п.  Поэтому, прежде чем добавлять новые~--- полезные~---
зависимости, следует рассмотреть способы оптимизации лишних зависимостей~--- зависимостей, которые можно
считать бесполезным.

Прежде всего, можно реализовать \textit{слияние} <<похожих>> зависимостей внутри отдельно взятого подпакета.
Например, зависимость с версией \verb|Provides: foo = 1.0| делает ненужной зависимость без версии \verb|Provides: foo|,
а из двух зависимостей с версиями \verb|Requires: bar >= 1.0| и \verb|Requires: bar >= 2.0| можно оставить только
одну~--- в данном случае с наибольшей версией.  В общем виде, с учетом всевозможных атрибутов зависимостей,
алгоритм слияния может быть довольно сложным.

Однако главным источником лишних зависимостей являются автоматически сгенерированные зависимости \verb|Requires|,
которые могут быть разрешены внутри своего подпакета в соответствующие зависимости \verb|Provides|.  Это
связано с тем, что скрипты геренации зависимостей \verb|Requires| обычно не учитывают то, что некоторые
из этих зависимостей предоставляются тем же самым пакетом (и поэтому всегда будут удовлетворены).
Вместо того, чтобы модифицировать скрипты генерации зависимостей, лучше реализовать глобальную оптимизацю:
исключать из пакета зависимости Requires, которые удовлетворяются зависимостями Provides в этом же пакете.
Эта оптимизация, однако, не может быть распространена на зависимости c некоторыми флагами типа \verb|Requires(pre)|~---
опять же, корректная реализация должна учитывать всевозможные специальные случаи.

В качестве примера рассмотрим зависимости пакета\\ \verb|perl-XML-SAX-0.960.0-2-mdv2011.0.noarch.rpm|.
\begin{verbatim}
Requires: perl(XML::SAX::PurePerl::DTDDecls)
Requires: perl(XML::SAX::PurePerl::DocType)
Requires: perl(XML::SAX::PurePerl::EncodingDetect)
Requires: perl(XML::SAX::PurePerl::Productions)
...
Provides: perl(XML::SAX::PurePerl::DTDDecls)
Provides: perl(XML::SAX::PurePerl::DebugHandler)
Provides: perl(XML::SAX::PurePerl::DocType)
Provides: perl(XML::SAX::PurePerl::EncodingDetect)
Provides: perl(XML::SAX::PurePerl::Exception)
Provides: perl(XML::SAX::PurePerl::Productions)
...
\end{verbatim}
Большую часть \verb|Requires| зависимостей в этом пакете следует отнести к лишним зависимостям~---
а именно, почти все зависимости вида \verb|perl(XML::SAX::...)|.

Оптимизация зависимостей может не ограничиваться зависимостями в пределах одного подпакета:
оптимизацию можно распространить на подпакеты, собираемые из одного исходного пакета, в том случае,
если подпакеты связаны строгой зависимостью.  \textit{Строгой зависимостью} мы называем зависимость
вида \verb|Requires: %name = %version-%release|, которая требует базовый подпакет с указанием не
только версии, но и релиза (номера сборки).  Тогда, если сборочная система не принимает пакеты
без последовательного увеличения либо версии, либо релиза, то можно считать, что строгая зависимость
уникально идентифицирует базовый подпакет.

Идея оптимизации состоит в том, что наличие строгой зависимости позволяет
оптимизировать некоторые другие~--- нестрогие~--- зависимости.  В качестве пример
рассмотрим зависимости пакета \verb|bzip2-1.0.6-3-mdv2011.0.x86_64.rpm|.
\begin{verbatim}
Requires: lib64bzip2_1 = 1.0.6-3
Requires: libbz2.so.1()(64bit)
Requires: libc.so.6()(64bit)
\end{verbatim}
Здесь первая зависимость является строгой~--- она уникально идентифицирует базовый подпакет с библиотекой сжатия.
В таком случае можно упразднить вторую зависимость~--- на soname библиотеки (эта зависимость предоставляется
базовым подпакетом, на который уже имеется строгая зависимость).

Вообще, если пакет \verb|%name-foo| содержит строгую зависимось на некоторый подпакет \verb|%name-base|,
то это позволяет удалить из пакета \verb|%name-foo| два рода \verb|Requires| зависимостей:
\begin{itemize}
\item Зависимости, которые \textit{представляются} пакетом \verb|%name-base|; или же, несколько точнее,
зависимости, которые могут быть удовлетворены \verb|Provides| зависимостями пакета \verb|%name-base|.
\item Зависимосте, которые \textit{уже требуются} пакетом \verb|%name-base|; или же, несколько точнее,
зависимости, которые могут быть подчинены \verb|Requires| зависимостям пакета \verb|%name-base|
в смысле возможности слияния.
\end{itemize}
В примере с \verb|bzip2| зависимость \verb|Requires: libc.so.6()(64bit)| относится к зависимостям второго рода
(базовый подпакет \verb|lib64bzip2_1| содержит такую же зависимость).

Некоторая сложность при оптимизации зависимостей второго рода связана с возможностью строгих \textit{циклических}
зависимостей.  \textit{Наивная} оптимизация зависимостей второго рода может привести к полному~--- <<циклическому>>~---
удалению зависимостей у подпакетов, которые образуют цикл.

Строгие зависимости между подпакетами можно наделить \textit{транзитивностью}: если подпакет \verb|foo| содержит
строгую зависимость на подпакет \verb|bar|, а подпакет \verb|bar| содержит строгую зависимость на подпакет \verb|baz|,
то можно считать, что подпакет \verb|foo| содержит строгую зависимость на пакет \verb|baz| (и оптимизировать зависимости
пакета \verb|foo| не только относительно пакета \verb|bar|, но и \verb|baz|).

Может возникнуть вопрос: в какой степени строгие зависимости действительно являются строгими?
Не стоит ли реализовать еще более строгие зависимости типа \verb|build-id|, которые идентифицируют пакет по его содержимому?
Можно указать два сценария, при которых строгие зависимости оказываются недостаточно строгими:
\begin{itemize}
\item Какой-либо посторониий пакет пердоставляет зависимость вида \verb|Provides: %name = %version-%release| и,
таким образом, удовлетворяет строгую зависимость Requires.
\item Сборка пакета выполняется без увеличения релиза (возможно, для другого дистрибутива), и возникает два набора пакетов.
Строгие зависимости не предотвращают <<перемешивания>> пакетов из обоих наборов.
\end{itemize}
В обоих случаях оптимизация зависимостей может оказаться некорректной, т.\,к. оптимизация выполняется в предположении,
что строгая зависимость уникально идентифицирует базовый пакет и его зависимости (а оказывается, что базовый пакет можно <<подменить>>).

На наш взгляд, возможность подмены базового пакета является скорее гипотетической, и на практике строгие зависимости
можно считать достаточно строгими.  Существует, однако, один дефект в реализации rpm, который может сделать строгие
зависимости менее строгими: сравнение версий у зависимостей выполняется таким образом, что зависимость вида
\verb|Provides: foo = %version| (с версией, но без релиза) удовлетворяет любую зависимость вида
\verb|Requires: foo = %version-%release| (с такой же версией и с релизом).
По-видимому, алгоритм сопоставления зависимостей в rpm должен быть скорректирован.

\section{Модульная система поиска зависимостей}
На последних стадиях сборки пакета выполняется автоматический поиск зависимостей:
rpm запускает скрипты \verb|find-requires| и \verb|find-provides|, которые анализируют
содержимое файлов в пакете и формируют соответственно \verb|Requires| и \verb|Provides| зависимости.

Почти во всех дистрибутивах скрипты \verb|find-requires| и \verb|find-provides| являются
монолитными программами, т.\,е. добавление новых типов зависимостей требует непосредственной модификации
этих скриптов.  Задача \textit{модульной системы поиска зависимостей}\footnote{См. также
\textit{Автоматический поиск зависимостей в rpm-пакетах} в сборнике
\url{http://www.altlinux.ru/media/protva4.pdf}}
состоит в том, чтобы для каждого типа зависимостей выделить соотвествующие программы поиска зависимостей
и сделать возможным независимое добавление зависимостей новых типов.  В скриптах \verb|find-requires| и \verb|find-provides|
должен остаться только вспомогательный код диспетчеризации.

Рассмотрим фрагмент монолитного скрипта \verb|find-requires|:
\begin{verbatim}
# --- Grab the file manifest and classify files.
exelist=`echo $filelist | xargs -r file | \
        grep -Ev ":.* (commands|script)[, ]" | \
        grep ":.*executable" | cut -d: -f1`
scriptlist=`echo $filelist | xargs -r file | \
        grep -E ":.* (commands|script)[, ]" | cut -d: -f1`

# --- Executable dependency sonames.
  for f in $exelist; do
    [ -r $f -a -x $f ] || continue
    lib64=`if file -L $f 2>/dev/null | \
        grep "ELF 64-bit" >/dev/null; then echo "$mark64"; fi`
    ldd $f | awk '/=>/ {
        if ($1 !~ /libNoVersion.so/ && $1 !~ /4[um]lib.so/) {
            gsub(/'\''"/,"\\&",$1);
            printf "%s'$lib64'\n", $1
        }
    }'
  done | xargs -r -n 1 basename | sort -u
\end{verbatim}
Данную схему поиска зависимостей можно описать так: сначала rpm классифицирует
все имеющиеся файлы и формирует разные категории файлов~--- \textit{отбирает} файлы
для поиска зависимостей, причем основным инструменом классификации является утилита \verb|file(1)|.
Затем для каждой группы выполняется анализ файлов и формируются соответствующие зависимости (в
приведенном фрагменте отбираются исполняемые программы и с помощью \verb|ldd(1)| определяются
разделяемые библиотеки, необходимые для запуска этих программ).

Скрипт \verb|find-requires| можно сделать модульным, если для каждого типа зависимостей выделить
две программы: программу \textit{отбора} файлов и программу \textit{анализа} файлов.  Тогда после реорганизации
работу скрипта \verb|find-requires| можно пояснить следующим образом:
\begin{itemize}
\item Утилита \verb|file(1)| запускается только один раз~--- в скрипте \verb|find-requires|.  Таким образом,
скрипт \verb|find-requires| формирует список файлов и их <<типов>>.  Дальнейшая работа \verb|find-requires|
сводится к вызову программ поиска зависимостей.  Для определенности будем рассматривать зависимости на разделяемые библиотеки.
\item Первая программа~--- с именем \verb|lib.req.files|~--- по списку файлов и их <<типов>> отбирает файлы,
которые содержат зависимости на разделяемые библиотеки.  Список отобранных файлов возвращается в \verb|find-requires|.
\item Затем \verb|find-requires| запускает вторую программу~--- с именем \verb|lib.req|~--- которая выполняет
анализ отобранных файлов и формирует список зависимостей на разделяемые библиотеки.
\end{itemize}

\textit{Модульность}\label{modular-approach} данной схемы состоит в том,
что \verb|find-requires| запускаются все имеющиеся программы поиска зависимостей
(по шаблону \verb|*.req.files| и \verb|*.req|) из каталога \verb|/usr/lib/rpm|.  Скрипт \verb|find-provides| работает аналогична
(запускаются программы с суффиксом \verb|.prov| вместо \verb|.req|).  Таким образом, для добавления нового типа зависимостей
нужно написать четыре программы: программу отбора файлов и программу анализа файлов, соответственно для Requires и Provides.

Другим аспектом модульности является возможность, в дополнение к новому типу зависимостей, реализовать макросы,
предназначенные для некоторой группы пакетов.  Как правило, такие макросы используются для того, чтобы упростить
сборку и унифицировать некоторые конструкции в спекфайлах (см. макросы для perl-пакетов в разделе \ref{perl-macros}).
Макросы также могут использоваться для того, чтобы управлять некоторыми параметрами сборки.

Макросы могут располагаться в отдельных файлах и подключаться по такому же модульному принципу.
Рассмотрим два вида файлов с макросами~--- файлы с суффиксом \verb|.def| и файлы с суффиксом \verb|.env|.
Файлы с суффиксом \verb|.def|\label{def-macro-files} являются традиционными файлами определения макросов.  Например,
в файле \verb|perl.def| определен следующий макрос, который позволяет в <<императивном стиле>> задать дополнительные
каталоги для perl-модулей:
\begin{verbatim}
%add_perl_lib_path()  %global _perl_lib_path %{?_perl_lib_path} %*
\end{verbatim}

У файлов с суффиксом \verb|.def| другое назначение~--- они позволяют <<вклиниваться>> в некоторые стадии сборки пакетов
с достаточно произвольным кодом, который генерируется с учетом текущего макроконтекста в спекфайле.
Например, в файле \verb|perl.env|\label{perl-env-intro} имеется следующая строка:
\begin{verbatim}
%{?_perl_lib_path:export RPM_PERL_LIB_PATH="%_perl_lib_path"}
\end{verbatim}
Таким образом, если в спекфайле был задан макрос \verb|_perl_lib_path|, то его значение экспортируется
в виде перменной окружения \verb|RPM_PERL_LIB_PATH|.  В дальнейшем значение этой переменной учитыватеся
в скриптах поиска зависимостей \verb|perl.req| и \verb|perl.prov|.

\section{Файловые зависимости и процедура find-package}
\label{file-deps}\textit{Файловыми зависимостями} мы называем зависимости вида \verb|Requires: /usr/foo|,
в~которых в качестве имени зависимости используется путь к файлу (или каталогу).  В rpm реализована
полная поддержка файловых зависимостей.  А именно, файловая зависимость может быть удовлетворена двумя способами:
\begin{itemize}
\item Если пакет предоставляет соответствующую зависимость \verb|Provides: /usr/foo|.
\item Если в пакете запакован файл (или каталог) \verb|/usr/foo|.
\end{itemize}
Таким образом, преимуществом файловых зависимостей является то, что их не нужно явно <<предоставлять>>~---
они предоставляются <<по факту>> наличия файлов в пакете.  Исключением являются <<альтерантивы>>, то есть
символические ссылки, создаваемые при установке программой \verb|update-alternatives| (такие пути должны
быть предоставлены через \verb|Provides|).

Другим преимуществом файловых зависимостей является то, что во многих случаях они являются наиболее точным
выражением \verb|Requires| зависимостей.  Например, если в каком-либо perl-скрипте имеется shebang-инструкция
\verb|#!/usr/bin/perl|, то работоспособность такого скрипта напрямую зависит от наличия интерпретатора \verb|/usr/bin/perl|.
Вместо зависимости на \verb|/usr/bin/perl| можно было бы указать зависимость на пакет \verb|perl-base| (или \verb|perl|,
если в дистрибутиве нет пакета \verb|perl-base|), но такая зависимость оказалась бы менее точной, т.\,к. она не гарантирует
напрямую наличие интерпретатора \verb|/usr/bin/perl| (кроме того, как уже видно, не всегда можно установить однозначное
соответствие между интерпретатором и именем пакета).

Хуже того, при сборке некоторых пакетов генерируются shebang-инструкция с указанием версии интерпретатора: \verb|#!/usr/bin/perl5.14.2|.
Если вместо файловой зависимости для такой инструкции сгенерировать зависимость на \verb|perl-base|, то эта зависимость
окажется не только неточной, но и очень хрупкой.  Зададимся вопросом: что будет при обновлении perl до новой версии?
Если была сгенерирована файловая зависимость, то при обновлении у пакетов с такой инструкцией появится неудовлетворенная
зависимость (и пакеты нужно будет пересобрать).  Если же сгенерировать зависимость на имя пакета, то обновление пройдет
без нарушения зависимостей, но пакеты утратят работоспособность~--- скрипты перестанут запускаться ввиду отсутствия
интерпретатора!  А это довольно неприятное последствие~--- получаются, что зависимости, которые
должны давать хотя бы минимальную гарантию работоспособности программы, на самом деле не дают и минимальной гарантии.

Таким образом, мы считаем, что файловые зависимости использовать не только уместно, но и необходимо во всех случаях,
когда зависимость может быть однозначно выражена в виде пути к файлу.

Хотя rpm полностью поддерживает файловые зависимости на базовом уровне (на уровне проверки зависимостей),
некоторые системы на основе rpm не поддерживают файловые зависимости как следует~--- не учитывают того,
что файловые зависимости могут разрешаться через обычные файлы, а не только через \verb|Provides|.
Дело в том, что при работе с репозиторием пакетов общий список файлов во всех пакетах может оказаться
довольно большим, и его обрабтка представляет некоторую сложность.  Рассмотрим два характерных случая:
\begin{itemize}
\item Система доступа к репозиторию вообще не учитывает файлов, запакованных в пакете, а учитывает только явные \verb|Provides|.
В системах такого рода нужно либо добавить <<распознавание>> файлов, либо вместо этого добавлять некоторые файловые пути прямо
в \verb|Provides|.  Однако, например, \verb|apt-rpm| изначально поддерживает файловые зависимости, так что для корректной работы
не требуется модификации клиентских программ.
\item Файловые зависимости не учитываются при <<индексировании>> репозитория, т.\,е. список файлов игнорируется при создании
метаинформации.  Как ни странно, этот случай характерен для \verb|apt-rpm|, и в одном российском дистрибутиве пришлось довольно
серьезно переделать процедуру генерации репозитория.  В таких системах порождение метаинформации должно выполняться в два
прохода: на первом проходе надо искать файловые зависимости, чтобы на втором проходе сохранить частичные списки файлов.
\end{itemize}
В связи с генерацией репозитория нужно учитывать еще один важный случай:
\begin{itemize}
\item Последовательная оверлейная сборка пакетов.  Пусть мы собираем пакеты на репозитории с корректной, но частичной
поддержкой файловых зависимостей.  Собранные пакеты помещаются в оверлейный репозиторий, который также используется
при сборке.  Тогда при сборке пакета A может образоваться файловая зависимость, для разрешения которой не хватает информации
в основном репозитории.  После этого не может быть выполнена сборка пакета B, который требует для сборки пакет A,
т.\,к. пакет A не может быть установлен.  В общем случае поддержка оверлейной сборки (двух и более пакетов) требует,
чтобы основной репозиторий был перегенирирован с полной информацией о файлах (именно такой подход используется в одном
российском дистрибутиве).
\end{itemize}
Итак, сборочная система и система доступа к репозиторию должны как следует поддерживать файловые зависимости.

Файловые зависимости генерируются не только для shebang-инструкций (см. раздел \ref{shebang-req}),
но и, например, при обработке символических ссылок (см. раздел \ref{symlinks-req}).  Для порождения
файловых зависимостей разработана вспомогательная библиотека шелл-функций \verb|/usr/lib/rpm/find-package|.
Изначально библиотека использовалась для анализа зависимостей в шелл-скриптах, поэтому основная процедура
\verb|FindPackage| на самом деле используется как для порождения файловых зависимостей, так и зависимостей
для \textit{команд}, т.\,е. для программ, вызываемых по имени (без указания полного пути программы).

При порождении файловых зависимостей в \verb|find-package| выполняется \textit{канониклизация} пути.
При этом должны быть учтены некоторые особенности сопоставления путей в каталоге \verb|%buildroot|
и в хост-системе.  Например, во многих дистрибутивах путь \verb|/etc/init.d| является символической
ссылкой, указывающей на каталог \verb|/etc/rc.d/init.d|.  Тогда, если в каком-либо скрипте загружается
файл \verb|/etc/init.d/functions|, то с учетом символической ссылки \verb|/etc/init.d|
должна быть сгенерирована файловая зависимость на \verb|/etc/rc.d/init.d/functions|.
Во многих других случаях, однако, содержимое каталога \verb|%buildroot| должно иметь приоритет над
содержимым корневой файловой системы.

Генерация зависимостей для команд рассмотрена в следующем разделе.

\section{Зависимости шелл-скриптов}
\label{shell-req}
Поднобнее остановимся на анализаторе зависимостей шелл-скриптов \verb|shell.req|, т.\,к. при
его реализации возникают вопросы, в разной степени характерные для многих других методов
поиска зависимостей.

Первичный анализ скрипта выполняется интерпретатором \verb|/bin/sh| с опцией \verb|--rpm-requires|,
т.\,е. задействуется специальный режим анализа кода, производный от режима проверки синтаксиса \verb|sh -n|.
Таким образом, дополнительным преимуществом \verb|shell.req| следует считать синтаксическую проверку
кода, выполняемую при поиске зависимостей.  Обнаружение синтаксических ошибок в скриптах можно отнести
к дополнительному тестированию, выполняемому при сборке (если \verb|shell.req| обнаруживает синтаксическую ошибку,
то сборка пакета завершается с ошибкой).  Проверка синтаксиса особенно важна для \%post-скриптов (см. раздел
\ref{post-script-deps}).

Особенностью шелл-скриптов является отсутствие специального механизма для указания требований (такого, как подключение
модулей в других языках программирования)~--- фактически, каждая \textit{команда} может порождать некоторую зависимость.
Вместе с отсутствием специального механизма исключений, который мог бы использоваться для условной загрузки кода,
это обостряет проблему порождения \textit{условных завсимостей}.  Например, для кода
\begin{verbatim}
if [ -f /etc/foo.conf ]; then
        . /etc/foo.conf
fi
if [ -f /usr/local/foo.conf ]; then
        . /usr/local/foo.conf
fi
\end{verbatim}
будут порождены файловые зависимости на \verb|/etc/foo.conf| и \verb|/usr/local/foo.conf|, при том,
что обе зависимости являются условными, а вторая~--- недопустимой (т.\,к. иерархия \verb|/usr/local|
не должна использоваться в пакетах).

Существует несколько способов, с помощью которых можно избежать порождения условных зависимостей:
\begin{itemize}
\item Можно переписать код таким образом, чтобы зависимось не порождалась.
Для этого можно <<спрятать>> команду или значение аргумента в переменную
\begin{verbatim}
foo=/usr/local/foo.conf
if [ -f $foo ]; then
        . $foo
fi
\end{verbatim}
либо дополнить команду специальным присваиванием, которое распознается анализатором
как инструкция игнорировать команду:
\begin{verbatim}
if [ -f /usr/local/foo.conf ]; then
        a= . /usr/local/foo.conf
fi
\end{verbatim}
Заметим, что в силу особенностей реализации интерпретатора зависимости в \textit{подстановках команд},
т.\,е. зависимости в конструкциях вида \verb|$(cmd ...)| также игнорируются.
\item Можно отфильтровать ненужные зависимости, используя специальные макросы в спекфайле
(см. раздел \ref{filter-deps}).
\item Для пакетов типа \verb|contrib| (содержащих скрипты, которые не предназначены для
непосредственного запуска пользователем) поиск шелл-зависимостей можно отключить:
\texttt{AutoReq: yes, noshell}.  Однако для пакетов, не относящихся к категории \verb|contrib|,
полностью отключать \verb|shell.req| не следует, т.\,к. желательно сохранить синтаксическую
проверку.  Вероятно, для такого класса пакетов нужно реализовать специальный режим
\texttt{AutoReq: yes, shell=syntax-check-only}.
\end{itemize}

Итак, синтаксический анализ позволяет обнаружить \textit{команды}, используемые в скрипте (аргументы некоторых стандартных команд,
как в примере с \verb|foo.conf|, также считаются командами).  Если команда имеет вид \textit{пути к файлу}, то для такой команды
\verb|find-package| порождает файловую зависимость; оставшиеся \textit{простые} команды подразделяются анализатором
на два вида: шелл-функции и исполняемые файлы.

Для простых команд выполняется \textit{элиминация зависимостей на функции}: формируется глобальный список шелл-функций,
которые определены в каком-либо файле в пределах пакета.  В дальнейшем команды с названием этих функций исключаются
из поиска зависимостей.  Дело в том, что интерпретатор не всегда может заранее определить, является ли вызываемая
команда функцией или исполняемым файлом.  Для реализации этой стадии требуется модифицировать режим \verb|--rpm-requires|
таким образом, чтобы в качестве зависимостей выводились не только вызываемые, но и все определяемые функции.

Оставшиеся команды считаются исполняемыми файлами, которые должны быть расположены в стандартных каталогах \verb|PATH|.
При формировании зависимостей для таких команд возникает следующее противоречие: с одной стороны, команды могут
перемещаться между каталогами (например, программу можно переместить из каталога \verb|/usr/bin| в каталог \verb|/bin|),
и тогда в качестве зависимости лучше использовать имя пакета.  В то же время файлы могут перемещаться между
подпакетами (например, программы из базового подпакета могут быть перенесены в дополнительный подпакет), и тогда
зависимость на имя пакета не гарантирует наличия команды.  Можно было бы использовать отдельное пространство имен
для исполняемых команд~--- \verb|command(foo)|, однако при этом теряется различие между \verb|sbin|-командами,
доступными только пользователю \verb|root|, и \verb|bin|-командами, доступными всем пользователям.  Поэтому
сейчас реализован компромиссный вариант, в котором по умолчанию генерируется зависимость на имя пакета.

Однако команда не всегда может быть однозначно сопоставлена с именем пакета.  Если приоритетный путь \verb|/usr/bin/foo|
предоставляется двумя пакетами с разным именем (обычно такой путь является <<альтернативой>>, хотя возможны и конфликтующие
реализации), то нужно сгенерировать файловую зависимости на \verb|/usr/bin/foo|.  Если же два разных пути находятся
в одном пакете (например, \verb|/bin/foo| и \verb|/usr/bin/foo|~--- обычно один из путей в таком случае является символической
ссылкой), то лучше сгенерировать зависимость на имя пакета.  При этом \textit{приоритет путей} может быть разным: для скриптов,
расположенных в каталогах \verb|/sbin|, \verb|/usr/sbin| и в некоторых других системных каталогах поиск команд выполняется
в порядке
\verb|/sbin|, \verb|/bin|, \verb|/usr/sbin|, \verb|/usr/bin|,
а для остальных скриптов~--- в порядке
\verb|/bin|, \verb|/sbin|, \verb|/usr/bin|, \verb|/usr/sbin|.
Как видно, различие между \verb|sbin|-скриптами и \verb|bin|-скриптами не является строгим~---
каталоги \verb|/sbin| и \verb|/usr/sbin| используются в обоих случаях.

Понятно, что результат поиска команды может зависеть не только от пакетов, установленных при сборке.  В частности,
по установленным пакетам нельзя определить, для каких команд имеются конфликтующие реализации.  Поэтому при сборке
пакета сборочная система формирует \textit{глобальный индекс команд} для всех пакетов в репозитории, который
мы называем \verb|contents_index_bin|.  Алгоритм \verb|find-package|, как правило, использует этот индекс в приоритетном
порядке (чтобы сформировать достаточно общие зависимости для команд, имеющих альтернативные и конфликтующие реализации).

Однако существует несколько реальных команд, как в следующем примере, у которых отличается как путь, так и название
пакета.
\begin{verbatim}
/usr/bin/arpsend        arpsend
/usr/sbin/arpsend       vzctl
\end{verbatim}
В таких случаях с помощью \verb|contents_index_bin| уже нельзя сформировать зависимость достаточно общего вида~---
придется делать выбор в пользу одной из конкретных реализаций.  Поэтому в таких случаях приоритет при поиске снова
отдается установленным пакетам, т.\,к. нужная реализация, возможно, используется при сборке пакета.

Необходимо заметить, что использование глобального индекса нарушает принцип \textit{воспроизводимости} сборки:
результат сборки пактов должен зависеть только от исходного кода и от пакетов, используемых при сборке (т.\,е. от пакетов,
установленных в сборочный чрут для <<чистовой>> сборки).  При использовании глобального индекса команд получается,
что зависимости пакета могут в некоторой степени зависеть и от других пакетов в репозитории.  Поэтому, во-первых,
политика дистрибутива должна ограничивать размещение <<левых>> команд в стандартных каталогах \verb|PATH|.  Во-вторых,
если сборочная система строго конролирует инвариант перехода (см. введение) и, в частности, фиксирует любые изменения
зависимостей у пакетов после тестовой пересборки, то нужно реализовать дополнительных механизм контроля зависимостей,
которые могут измениться только из-за содержимого \verb|contents_index_bin|.

В последнее время появились предложения по объединению каталогов \verb|/bin| и \verb|/sbin| с каталогами в иерархии \verb|/usr|.
В связи с этим некоторые подходы, описанные в данном разделе, могут быть пересмотрены.
\pagebreak

\section{Сборка perl-пакетов~--- rpm-build-perl}
Модульный подход, обозначенный в разделе \ref{modular-approach}, позволяет независимо разрабатывать
компоненты, дополняющие базовую политику сборки.  Одним из таких компонентов является пакет \verb|rpm-build-perl|.
В этот пакет вынесены скрипты поиска зависимостей и еще несколько файлов, относящихся к языку perl или направленных
на поддержку сборки perl-пакетов.  При этом в пакет \verb|rpm-build| добавлена зависимость на \verb|rpm-build-perl|~---
таким образом, поддержка perl-зависимостей сохранена для всех пакетов.  Некоторые другие расширения,
однако, не могут быть внесены в базовую сборочную среду; для таких расширений должна быть продумана специальная
схема поддержки зависимостей (см. \verb|rpm-build-mono| в разделе \ref{rpm-build-mono}).

Пакет \verb|rpm-build-perl| содержит следующие компоненты:
\begin{itemize}
\item Скрипт формирования Requires зависимостей \verb|perl.req| и соответствующий ему скрипт отбора файлов \verb|perl.req.files|.
\item Скрипт формирования Provides зависимостей \verb|perl.prov| и соответствующий ему скрипт отбора файлов \verb|perl.prov.files|.
\item Скрипт \verb|perl.clean| для очистики каталога \verb|%buildroot| на стадии brp.
\item Файл \verb|perl.def| с макросами, которые используются при сборке perl-пакетов.
\item Файл \verb|perl.env| для управления параметрами сборки (см. раздел \ref{perl-env-intro}).
\end{itemize}

По сравнению с традиционной реализацией было изменено представление зависимостей для модулей:
вместо \verb|perl(File::Spec)| используются зависимости вида \verb|perl(File/Spec.pm)|,
т.\,е. вместо имени модуля используется соответствующие компоненты имени файла.
Таким образом, выбрано унифицированное представление зависимостей для модулей и зависимостей
вида \verb|perl(getopts.pl)| и \verb|perl(sys/ioctl.ph)|.

Кратко остановимся на некоторых особенностях сборки perl-пакетов.  Базовая совместимость модулей
с интерпретатором выражается через зависимости на каталоги (см. раздел \ref{files-req}), при этом
не используется версионирование каталогов (механизм \verb|inc_version_list|
отключен при сборке интерпретатора).  Вообще, структура каталогов для модулей подвергнута максимальному упрощению.
Так, все модули из noarch пакетов располагаются в каталоге \verb|/usr/share/perl5|, так что результат
сборки таких пакетов, как правило, не зависит от версии интерпретатора.  Однако для компилируемых
модулей зависимости на каталог \verb|/usr/lib/perl5| или \verb|/usr/lib64/perl5| будет недостаточно.
Процедура сборки perl-расширений модифицирована таким образом, чтобы загружаемые объекты \verb|.so| компоновались
с библиотекой libperl.  А библиотека libperl в свою очередь наделяется именем (soname) вида \verb|libperl-5.14.so|.
Таким образом, бинарная совместимость модулей и интерпретатора конролируется стандартным способом~--- через
зависимости на soname библиотеки, при этом также используются set-версии (см. раздел \ref{set-versions}).
Всё это позволяет сформировать более \textit{точные} и менее \textit{жесткие} зависимости, которые позволяют
контролировать не только \textit{обратную}, но и \textit{прямую} совместимость (например,
бинарную совместимость модуля, собранного с новой версией интерпретатора, с более старой версией интерпретатора).

\subsection{Анализатор зависимостей perl.req}

Загрузка модулей в языке perl выполняется с помощью функции \verb|require| или
инструкции \verb|use| (которая сводится к вызову функции \verb|require|).
В традиционной реализации скрипт \verb|perl.req| с помощью регулярного
выражения ищет строки, которые начинаются со слов \verb|require| или \verb|use|,
и выполняет дальнейший разбор этих строк.

Рассмотрим фрагмент традиционной реализации \verb|perl.req|.
\begin{verbatim}
if (m/^(\s*)         # we hope the inclusion starts the line
    (require|use)\s+(?!\{)     # do not want 'do {' loops
    # quotes around name are always legal
    ['"]?([^; '"\t#]+)['"]?[\t; ]
    # the syntax for 'use' allows version requirements
    # the latter part is for "use base qw(Foo)" and friends special case
    \s*($modver_re|(qw\s*[(\/'"]\s*|['"])[^)\/"'\$]*?\s*[)\/"'])?
    /x)
) {
my ($whitespace, $statement, $module, $version) = ($1, $2, $3, $4);

# we only consider require statements that are flushed against
# the left edge. any other require statements give too many
# false positives, as they are usually inside of an if statement
# as a fallback module or a rarely used option
($whitespace ne "" && $statement eq "require") && next;

# skip if the phrase was "use of" -- shows up in gimp-perl, et al.
next if $module eq 'of';
\end{verbatim}
Как видно, регулярное выражение нельзя назвать простым.  Кроме того, регулярного выражения оказывается недостаточно.
Язык perl характеризуется очень сложным синтаксисом~--- неоднородной системой кавычек и ограничителей, многострочными
литералами here-documents, наконец, встроенной документацией pod.  Не случайно последняя проверка в приведенном фрагменте
<<отсеивает>> типичное вхождение слова <<use>> в предоложения английского языка (в дальнейшем выполняется еще несколько
похожих проверок).  Обращает на себя внимание и первая проверка: она оставляет только строки без отступа (а строки с отступом
считаются условными конструкциями).  Однако отступы в языке perl не являются значащами.  Кроме того, уровень вложенности
не всегда означает условную конструкцию, как в следующем типичном примере:
\begin{verbatim}
BEGIN {
    use Exporter;
    @EXPORT = qw(foo bar);
}
\end{verbatim}
Следует также отметить, что инструкции \verb|use| выполняются всегда (на стадии загрузки кода),
и поэтому понятие условных конструкций к ним не относится.

Таким образом, разбор кода на языке perl с помощью регулярных выражений нельзя считать надежным подходом.
Вообще, как говорят хакеры, <<Only perl can parse perl>>, т.\,е. надежный разбор кода на языке perl
может быть выполнен только средствами самого интерпретатора perl.

К счастью, интерпретатор предоставляет доступ к внутреннему представлению кода.  При загрузке кода
интерпретатор формирует дерево опкодов (которое обладает как признакми синтаксического дерева,
так и признаками байткода); в дальнейшем дерево <<выполняется>> с помощью отдельной процедуры (которую
можно считать прототипом виртуальной машины).  Модуль \verb|B|, иногда называемый <<компилятором>>,
предоставляет доступ к дереву опкодов, а также позволяет отключить основную стадию исполнения кода
(активизируя режим проверки синтаксиса \texttt{perl -c}).  Модуль \verb|O| иногда называют <<интерфейсом
компилятора>>~--- он упрощает загрузку дополнительных модулей, работающих в <<режиме компилятора>>.

Модуль \verb|B::Concise| позволяет отобразить дерево опкодов:
\begin{verbatim}
$ perl -MO=Concise -e 'require Foo; print 1'
9  <@> leave[1 ref] vKP/REFC ->(end)
1     <0> enter ->2
2     <;> nextstate(main 1 -e:1) v:{ ->3
4     <1> require sK/1 ->5
3        <$> const[PV "Foo.pm"] s/BARE ->4
5     <;> nextstate(main 1 -e:1) v:{ ->6
8     <@> print vK ->9
6        <0> pushmark s ->7
7        <$> const[IV 1] s ->8
-e syntax OK
\end{verbatim}

Дерево опкодов сохраняет всю важную информацию об исходном коде.
Модуль \verb|B::Deparse| позволяет реконструировать исходный код:
\begin{verbatim}
$ perl -MO=Deparse -e 'require Foo; print 1'
require Foo;
print 1;
-e syntax OK
\end{verbatim}

Идея <<нетрадиционной>> реализации \verb|perl.req| состоит в том, чтобы вместо регулярного выражения
использовать для извлечения зависимостей вспомогательный модуль \verb|B::PerlReq| (разработанный специально
для этой цели):
\begin{verbatim}
$ perl -MO=PerlReq -e 'require Foo; print 1'
perl(Foo.pm)
-e syntax OK
\end{verbatim}

Основным источником зависимостей в дереве опкодов являются опкоды \verb|require|, которые соответствуют
непосредственным вызовам функции \verb|require| и инструкциям \verb|use|.  Однако к образованию зависимостей
могут приводить и некоторые другие конструкции.  Например, версионирование зависимостей осуществляется
с помощью вызова статического метода \verb|VERSION|: инструкция вида
\begin{verbatim}
use Module 1.0 qw(list);
\end{verbatim}
на самом деле <<раскрывается>> в код
\begin{verbatim}
BEGIN {
    require Module;
    Module->VERSION(1.0);
    Module->import(list);
}
\end{verbatim}
Поэтому в модуле \verb|B::PerlReq| в качестве общего случая реализован анализ вызовов функций
и статических методов (в том числе выполняется реконструкция константных аргументов).  Это
позволяет обнаруживать отложенную загрузку модулей вида
\begin{verbatim}
use autouse Foo => qw(bar baz);
\end{verbatim}
за счет обработки вызова статического метода \verb|autouse->import|:
\begin{verbatim}
$ perl -MO=PerlReq -e 'use autouse Foo => qw(bar baz)'
perl(autouse.pm)
perl(Foo.pm)
-e syntax OK
\end{verbatim}

Анализ вызова функций и статических методов позволяет обнаружить довольно сложные способы образования
зависимостей.  Например, в следующих двух случаях
\begin{verbatim}
open $fh, ">", \$var;
IO::File->new(\$var, "w");
\end{verbatim}
при открытии файла вместо имени файла передается ссылка на переменную \verb|$var|.
В таких случаях доступ к файлу на диске заменяется доступом к содержимому переменной \verb|$var| (т.\,н. in-memory files).
Примитивы доступа к таким псевдофайлам реализованы в модуле \verb|PerlIO::scalar|, который загружается интерпретатором
по мере необходимости.  Соответствено, при обнаружении подобных конструкций модуль \verb|B::PerlReq| порождает зависимость
на \verb|perl(PerlIO/scalar.pm)|.

Подробнее рассмотрим проблему условных зависимостей.  Функция \verb|require|, которая выполняет загрузку модулей, всегда
возвращает истинное значение.  Если же модуль загрузить не удается, то функция \verb|require| генерирует исключение, которое,
как правило, приводит к аварийному завершению программы.  Единственный способ перехватить исключение~--- заключить вызов
\verb|require| в блок \verb|eval|.  Это определяет основное правило обработки условных зависимостей, принятое в модуле
\verb|B::PerlReq|: условными считаются только зависимости, которые возникают внутри блоков \verb|eval| (такие зависимости игнорируются).
В то же время не игнорируются, например, зависимости на модули, загружаемые внутри функций, если вызовы \verb|require| в функциях
не <<защищены>> блоком \verb|eval|.

Одна из проблем при таком подходе, однако, связана с тем, что для условных зависимостей часто характерна <<обратная логика>>.
Рассмотрим следующий пример:
\begin{verbatim}
eval {
    require Foo;
};
if ($@) {
    # Foo not available, fall back to Bar
    require Bar;
}
\end{verbatim}
В этом примере предпринимается попытка загрузить модуль \verb|Foo|, а модуль \verb|Bar| загружается только в случае,
если модуль \verb|Foo| загрузить не удалось.  В соответствии с логикой обработки условных зависимостей будет сгенерирована
зависимость \verb|perl(Bar.pm)|.  Однако <<по смыслу>> более предпочтительной была бы зависимость \verb|perl(Foo.pm)|~---
если модуль \verb|Foo| существует и его удается загрузить.

Понятно, что в общем случае проблему <<обратной логики>> условных зависимостей решить довольно сложно~--- потребовалось
бы реализовать предсказание переходов.  Однако в некоторых случаях, продолжая аналогию <<Only perl can parse perl>>, можно
рассчитывать на исполнение кода самим интерпретатором.  Например, поскольку блоки \verb|BEGIN| выполняются только один раз и
в безусловном порядке, то при обработке блоков \verb|BEGIN| можно просто проверять (через \verb|%INC|), какие модули были
фактически загружены интерпретатором.  Аналогичная возможность может быть распространена на <<основной код>> модулей
(код инициализации), если реализовать специальный режим загрузки модулей \verb|modexec|, при котором не только загружается
текст, но и выполняется код инициализации (режим \verb|modexec| пока не реализован, однако трудности реализации не являются
принципиальными).  В то же время режим исполнения кода не может быть распространен на скрипты, т.\,к. выполнение
скриптов обычно связано с побочными эффектами.

\subsection{Макросы и автоматизация сборки}
\label{perl-macros}

В данном разделе рассматривается сборка perl-модулей, распространяемых через CPAN.
Сборка пакетов выполняется по одинаковой схеме:
\begin{verbatim}
%prep
%setup -q -n Foo-%version

%build
perl Makefile.PL INSTALLDIRS=vendor
make

%check
make test

%install
make install DESTDIR=%buildroot

%files
%perl_vendorlib/Foo*
\end{verbatim}

В некоторых пакетах, однако, вместо \verb|Makefile.PL| используется \verb|Build.PL|;
в таких пакетах сборка идет по другой схеме: вместо \verb|Makefile| создается скрипт \verb|Build|,
который используется в качестве самостоятельной программы вместо \verb|make(1)|.

Можно реализовать вспомогательные макросы, в которых выбор нужной схемы сборки будет выполняться
автоматически.  Тогда соответствующие секции спекфайла будут выглядеть следующим образом:
\begin{verbatim}
%build
%perl_build

%check
%perl_check

%install
%perl_install
\end{verbatim}
В результате мы получаем не только максимальное \emph{упрощение}, но и максимальную \emph{унификацию}
сборки perl-пакетов.  А унификация важна сама по себе: лишние степени свободы
далеко не всегда могут быть использованы для улучшений, зато часто являются источником <<разнобоя>>.
Последовательность команд для сборки, даже правильная, всегда может стать предметом для проверки.
А если сборка полностью унифицирована, то в этом отношении в пакетах попросту <<нечего исправлять>>.

Кроме того, что полученная конструкция является унифицированной, ее можно считать достаточно \emph{надежной}:
почти все пакеты содеражат тесты, которые выполняются при сборке; зависимости должны обеспечить
работоспособность пакета при установке; а также поиск зависимостей подразумевает синтаксическую проверку кода
(режим \verb|modexec| должен дополнительно гарантировать загружаемость модулей).
Таким образом, получить в результате использования этой конструкции неработоспособный пакет довольно сложно.

Дальнейшая автоматизация сборки связана с возможностями, предоставляемыми CPAN.
CPAN экспортирует информацию о модулях в хорошо структурированном виде, что позволяет
вычислить список модулей, которые должны быть обновлены:
\begin{verbatim}
$ perl -MCPAN -e 'CPAN::Shell->r'
Package namespace  installed  latest  in CPAN file
AnyEvent                6.02    6.12  MLEHMANN/AnyEvent-6.12.tar.gz
Apache::DBI             1.10    1.11  PHRED/Apache-DBI-1.11.tar.gz
Archive::Extract        0.56    0.58  BINGOS/Archive-Extract-0.58.tar.gz
...
\end{verbatim}

Следует отметить, что в любом современном дистрибутиве должно быть порядка 1000 perl-пакетов (пакеты, на которые существует <<спрос>>).
Понятно, что автоматизация обновления perl-пакетов в таком случае становится довольно актуальной задачей.  Однако системы
автоматизированного обновления perl-пакетов, которая целиком бы нас устраивала, пока не создано.
Дальнейшее обсуждение автоматизации сборки выходит за рамки данного документа.  Заметим только, что при автоматизации
должна быть сохранена возможность проверки пакета человеком~--- перед тем, как пакет будет направлен в репозиторий.
Таким образом, \emph{автоматизированное} обновление не означает \emph{слепое} обновление.

\section{Зависимости на ELF-библиотеки, set-версии}
Исполняемые файлы и разделяемые библиотеки в формате ELF являются основной реализации пользовательского пространства ОС.
Формат ELF также является основой спецификации System~V Application Binary Interface, которая является составной частью
UNIX и Linux стандартов.  Следует отметить, что формат ELF реализует низкоуровневые возможности и не предоставляет механизма
обработки ошибок и исключительных ситуаций: в нештатной ситуации~--- например, при обнаружени несовместимости~--- работа
приложения аварийно завершается.  Поэтому поддержку бинарной совместимости можно считать приоритеной задачей для системы
управления пакетами.  Перефразируя
\emph{тезис Силина},\footnote{\textit{Расходы, затраченные на управление виртуальной памятью, окупаются.}
Игорь Силин~--- разработчик ОС <<Дубна>> для БЭСМ-6.}
можно сказать, что расходы, затраченные на поддержку бинарной совместимости, окупаются.

В современных дистрибутивах Linux программы \emph{динамически} компонуются с разделямыми библиотеками.
Запуск таких программ выполняется с помощью вспомогательной программы~--- загрузчика \verb|ld.so|,
который конструирует исполняемый образ программы (полный путь к загрузчику содержится в сегменте \verb|PT_INTERP| программы).
При этом происходит загрузка необходимых разделяемых библиотек (список библиотек содержится в секции \verb|DT_NEEDED| программы).
Разделяемые библиотеки в свою очередь могут требовать другие разделяемые библиотеки.  После того, как все требуемые библиотеки
загружены, загрузчик выполняет проверку версионированных интерфейсов~--- наличие интерфейсов типа \verb|GLIBC_2.4| (информация
о которых содержится в секциях \verb|DT_VERDEF| и \verb|DT_VERNEED|).  После этого выполняется подготовка к запуску, и загрузчик
передает управление в стартовую процедуру программы.  \emph{Разрешение символов} обычно выполняется во время работы программы:
поиск функции по имени выполняется при первом обращении к функции.

Таким образом, чтобы обеспечить бинарную совместимость динамически компонуемых программ и разделяемых библиотек,
rpm должен фактически следовать логике загрузчика \verb|ld.so|.  А именно, rpm должен контролировать следующие
аспекты совместимости:
\begin{itemize}
\item Возможность загрузки необходимых разделяемых библиотек.
\item Наличие необходимых версионированных интерфейсов.
\item Разрешимость символов во время работы программы.
\end{itemize}

Традиционно rpm контролирует только первые два аспекта совместимости (особенности реализации обсуждаются
далее в разделе \ref{lib-namespace}).  Последний аспект является новым: поддержка зависимостей, в которых учитывается
информация о символах, была реализована относительно недавно (релизация рассмотрена в разделе \ref{set-versions}).

\subsection{Пространство имен библиотек}
\label{lib-namespace}
В традиционной реализации для всех библиотек используется глобальное пространство имен, независимо
от каталога, в котором расположена библиотека, и без учета назначения библиотеки.  Это порождает
много ненужных Provides зависимостей.

Например, пакет \verb|perl-XML-LibXSLT-1.700.0-4-mdv2011.0.x86_64.rpm| предоставлят зависимость \verb|Provides: LibXSLT.so()(64bit)|,
которая соответствует файлу \texttt{/usr/lib/perl5/.../auto/XML/LibXSLT/LibXSLT.so}.  Однако этот файл не является <<библиотекой>>
общего назначения в том смысле, что он не предназначен для динамической компоновки и не будет загружаться через \verb|DT_NEEDED|.
Это файл является <<плагином>> для интерпретатора perl и будет загружаться через \verb|dlopen(3)|.  Поэтому он расположен
в специальном каталоге, в котором его будет искать интерпретатор.

Эта проблема лишних зависимостей уже обратила на себя внимание.  Так, в проекте Fedora реализован макрос для
фильтрации зависимостей \verb|%perl_default_filter|, который предлагается добавлять в спекфайлы perl-пакетов.

Проблему лишних зависимостей, однако, не следует понимать исключительно как проблему оптимизации.
Зависимости имен библиотек неявно образуют пространство имен.  Это пространство имен наделяется
определенной семантикой: если какой-либо пакет требует зависимость вида \verb|libfoo.so.1|,
то он рассчитывает, что динамический загрузчик сможет загрузить эту библиотеку в конфигурации
по умолчанию (т.\,е. библиотека должна быть найдена в стандартном системном каталоге);
соответственно, если какой-либо пакет предоставляет зависимость \verb|libfoo.so.1|,
то библиотека \verb|libfoo.so.1| должна стать доступна в конфигурации по умолчанию, т.\,е.
располагаться в стандартном системном каталоге.  С другой стороны, какой-либо пакет может
содержать копию библиотеки \verb|libfoo.so.1| в своем <<приватном>> каталоге (такая практика
не поощряется, но в принципе пакет <<имеет право>> содержать в приватном каталоге любые библиотеки).
Такие приватные библиотеки не должны влиять на разрешение системных зависимостей.

Таким образом, мы предлагаем использовать пространство имен вида \verb|libfoo.so.1| только для
библиотек, доступных в конфигурации по умолчанию, т.\,е. для библиотек, расположенных в каталогах
\verb|/lib|, \verb|/usr/lib| (на архитектуре i686) и в каталогах \verb|/lib64|, \verb|/usr/lib64|
(на архитектуре x86-64).

В некоторых случаях, однако, динамический загрузчик может загружать библиотеки из нестандартных
каталогов~--- например, при использовании в исполняемом файле пути к библиотекам \verb|RPATH|.
Для указания зависимостей на такие библиотеки можно использовать файловые зависимости~---
зависимости вида \texttt{Requires: /usr/foo/libfoo.so.1} (см. раздел \ref{file-deps}).
Преимуществом таких зависимостей является то, что для их разрешения не требуется соответствующих
Proivdes зависисимостей~--- достаточно фактического наличия нужного файла в каталоге \verb|/usr/foo|.

Недостатком же файловых зависимостей является отсуствие версионирования~--- в предолженной схеме
с использованием простых файловых зависимостей невозможно выразить требования на версионированные
интерфейсы и на символы.  Поэтому в некоторых случаях файловые зависимости могут <<наращиваться>>
соответствующими Provides зависимостями, сформированными на основе имени файла, т.\,е. зависимостями
вида \texttt{Provides: /usr/foo/libfoo.so.1(FOO\_1.0)}.  При этом префикс \verb|/usr/foo| можно также
трактовать как пространство имен, которое отделяет библиотеку \verb|libfoo.so.1| от стандартного
пространства имен.

Для <<наращивания>> зависимостей в спекфайле с помощью макроса должен быть задан каталог
с приватными библиотеками: \verb|%add_findprov_lib_path /usr/foo|.

Если приватные библиотеки используются только внутри пакета (или внутри подпакетов одного пакета),
то <<наращивания>> зависимостей не требуется: будет сформирована файловая зависимость, которая в дальнейшем должна
быть оптимизирована (в том числе и в подпакетах, которые связаны строгими зависимостями~--- см. раздел \ref{deps-optimization}).
Наращивание может быть полезным только в случаях, когда библиотеки, расположенные в нестандартном каталоге, активно используются
другими пакетами.  Однако такие случаи редки, и обычно такие библиотеки следует переносить в системный каталог.

К спорным особенностям реализации зависимостей можно отнести возможность использования дополнительных <<стандартных>> каталогов.
С одной стороны, загрузчик \verb|ld.so| предоставляет стандарнтую возможность добавления каталогов
через файлы конфигурации \verb|/etc/ld.so.conf| и \verb|/etc/ld.so.conf.d/*|.  С другой стороны, использование этой возможности
требует дополнительного конторля конфигурации \verb|ld.so|.  Фактически требуется контролировать содержимое конфигурационных
файлов \verb|ld.so.conf|~--- чтобы в одном из них всегда был указан нужный каталог.  Однако rpm допускает модификацию
конфигурационных файлов.

\subsection{Версионирование интерфейса, set-версии}
\label{set-versions}
При разработке ПО большое внимание уделяется обратной совместимости.  \emph{Обратная совместимость}
означает, что новая версия разработанного компонента ПО будет работать в старом окружении~--- сохраняет совместимость.
Однако обратная совместимость не может обеспечить все \emph{реальные} требования совместимости.  Вообще,
при запуске программы не существует <<обратной>> совместимости, а существует \emph{просто совместимость}.
Если компоненты программы совместимы, то она будет работать.  А в противном случае компоненты программы несовместимы,
и программу следует считать неработоспособной.

Ситуации, когда обратной совместимости оказывается недостаточно, часто возникают при использовании разделяемых
библиотек.  Это связано с тем, что версии пакетов могут обновляться асинхронно и использоваться в разных комбинациях,
не предусмотренных хронологией разработки.  Поясним это на следующем примере.  Разработчик библиотеки, добавляя новые функции в библиотеку,
считает, что он сохраняет обратную совместимость~--- существующие программы будут работать с новой версией библиотеки.
Однако пользователь репозитория пакетов обычно хочет обновить интересную ему программу.  Тогда в комбинации <<новая программа
со старой библиотекой>> могут образоваться неразрешимые символы (при обнаружении неразрешимых символов программа аварийно завершается).

Таким образом, требования обратной совместимости часто должны быть дополнены требованием <<минимальной версии>> библиотеки~---
такой версии, в которой реализованы все функции, используемые в программе.  С помощью \emph{версионированных интерфейсов}
можно наделить набор новых функций специальной меткой вида \verb|FOO_1.0|, которая в дальнейшем будет учитываться в зависимостях
(т.\,е. появится зависимость на \verb|libfoo.so.1(FOO_1.0)|, если используется какая-либо функция из интерфейса \verb|FOO_1.0|).
Однако следует отметить, что версионированные интерфейсы являются, во-первых, очень хрупкой конструкцией.
Например, версионирование не очень строго учитывается при разрешении символов: загрузчик \verb|ld.so| допускает не только
разрешение неверсионированной ссылки в версионированный символ, но и наоборот, разрешение версионированной ссылки в неверсионированный
символ (чтобы сохранить возможность переопределения версионированных символов через \verb|LD_PRELOAD|).  Кроме того,
версионированные интерфейсы не должны заполянться постепенно, а должны появляться <<одновременно>> с набором новых функций,
что плохо согласуется с инкрементальной разработкой.  Если же добавлять функции в интерфейс постепенно, то мы возвращаемся
к прежней проблеме: наличие интерфейса оказывается недостаточным для того, чтобы гарантировать наличие нужных функций.
Конечно, можно попытаться запретить использовать <<нестабильные>> версии библиотек с частично заполненными интерфейсами,
но это не решает проблему гарантий на уровне зависимостей.  Для использования промежуточных версий библиотек на самом деле
требуется б\'{о}льшая \emph{гранулярность} версионирования~--- в пределе, каждый новый символ библиотеки нужно снабжать
отдельным интерфейсом (тогда наличие интерфейса будет напрямую гарантировать наличие символа).

Во-вторых, использование версионированных интерфейсов не получило широкого распространения (например, оно не используется
в библиотеках GNOME и KDE).  Отчасти это связано с тем, что информацию о версионированных интерфейсах нужно поддерживать <<вручную>>,
отчасти~--- с ограниченной совместимостью (версионирование поддерживается только в загрузчике \verb|ld.so| из \verb|glibc|).
В одном российском дистрибутиве мы предприняли попытку самостоятельно поддерживать версионированные интерфейсы в пакетах
с библиотеками.  Однако такой подход приводит к тому, что программы, собранные в одном российском дистрибутиве, перестают
запускаться в других дистрибутивах (т.\,к. требуются отсутствующие версионированные интерфейсы).  Кроме того, как уже отмечено,
поддержка версионированных интерфейсов не может быть полностью автоматизирована, и каждый раз при сборке новой версии пакета
с библиотекой требуется работа по обновлению и квалифицированная проверка.
В дальнейшем мы отказались от использования <<самодельных>> версионированных интерфейсов.

Рассмотренная проблема <<минимальной версии>> не является единственной проблемой, которая приводит к нарушению бинарной совместимости.
Часто авторы библиотек сознательно допускают нарушение обратной совместимости, удаляя устаревшие функции в новых версиях библиотек.
Авторы также могут считать, что они вправе изменять недокументированные функции и т.\,п.  Как бы там ни было, в исследовани,
выполненном в ИПС РАН,\footnote{См. \emph{Автоматизированный анализ обратной совместимости Linux-библиотек} в сборнике
\url{http://docs.altlinux.org/archive/conference/trubezh2010.pdf}} удаление функций и глобальных переменных названо
главной проблемой бинарной совместимости.  Некоторые другие аспекты бинарной совместимости, такие, как изменение типа данных
параметра в языке C++ или добавление спецификатора \verb|static|, тоже связаны с разрешением символов.

Все эти соображения привели к разработке новой модели зависимостей,\footnote{См. \textit{Комплементарное хеширование подмножеств} там же.}
направленной на <<просто совместимость>>, т.\,е. такой модели, в которой напрямую гарантируется наличие нужных символов.  В этой модели
интерфейс, предоставляемый библиотекой, формализуется как множество символов $P$~--- множество функций и глобальных переменных библиотеки;
а требуемя версия библиотеки формализуется как множество библиотечных символов $R$, используемых в программе.  Программа совместима
с библиотекой, если $R\subseteq P$.  Несколько точнее, пусть имеется несколько версий библиотеки с разновидностями интерфейса
$P_0,P_1,\ldots$ и несколько версий программы, в которых используются наборы символов $R_0,R_1,\ldots$  Тогда версия библиотеки $P_i$
совместима с версией программы $R_j$, если $R_j\subseteq P_i$.

В данной модели символы ассоциируются с библиотеками, то есть считается установленным локальное соответствие между
библиотечными символами, используемыми в программе, и библиотеками.  Формат ELF, вообще говоря, не требует такого соответствия:
в программе содержится только список используемых библиотек и список неопределенных символов, а поиск символов в библиотеках
не ограничивается.  Другими словами, формат ELF допускает <<перемешивание>> символов между библиотеками.  Таким образом,
данная модель несколько ограничивает то, что изначально считается допустимым.  Однако мы не считаем это серьезной проблемой.
Во-первых, <<перемешивание>> символов между библиотеками еще не встречалось нам на практике.  Во-вторых, есть основания думать,
что символы в действительности \emph{должны} быть ассоциированы с библиотеками, т.\,к. каждый символ является частью интерфейса
библиотеки.  Так, в \emph{System V Application Binary Interface} в разделе 6 функции <<приписываются>> к библиотекам.
В OpenSolaris реализована процедура разрешения символов <<Direct binding>>, при которой символы разрешаются сразу
в нужные библиотеки (эту процедуру можно трактовать и как оптимизацию, и как защиту от пересечения с пользовательскими символами).

Возникает также вопрос, как установить соответствие между символами и библиотеками.  Для этого мы используем вспомогательную
программу, основанную на \verb|ldd(1)|, в которой фактически выполняется запуск загрузчика \verb|ld.so| в специальном <<отладочном>>
режиме.  Загрузчик в этом режиме загружает раздялемые библиотеки, полностью выполняет разрешение символов и выводит <<отладочную>>
информацию о загрузке библиотек и разрешении символов, но не передает управление в стартовую процедуру программы.  Таким образом,
как и в случае с perl-зависимостям, используется <<эмпирический>> подход: чтобы узнать, как <<в действительности>> разрешаются символы,
нужно использовать <<родной механизм>>.  Использование <<родного механизма>> также связано с нашим пониманием гарантий, которые
могут быть предоставлены системой управления пакетами.  Дело в том, что при сборке пакета выполняется согласование кода пакета
с окружением, в котором собирается пакет.  Тогда саму сборку пакета можно рассматривать как момент \emph{наибольшего согласования}.
Действительно, во время сборки программа обычно хорошо совместима с теми библиотеками, с которыми она собирается; несовместимость
появляется только при работе в других конфигурациях (с другими версиями библиотек).  Поэтому использование <<родного механизма>>
для разрешения символов можно считать частью \emph{переноса гарантий}, достигнутых в момент наибольшего согласования, на другие
конфигурации.  А именно, зависимости будут гарантировать, что при запуске программы символы будут разрешаться в некотором смысле
\emph{не хуже}, чем во время сборки пакета.

Понятно, что предложенная модель является слишком громоздкой~--- количество символов исчисляется сотнями даже в простых случаях,
а названия символов в языке C++ бывают длинные.  Поэтому напрямую символы не могут быть внесены в зависимости.
Но строго говоря, нам и не нужно хранить полный список символов, а нужно лишь уметь проверять, являются ли требуемые
символы подмножеством предоставляемых.  Возникает вопрос, нельзя ли придумать такую процедуру хеширования двух
множеств $R$ и $P$, при которой сохраняется возможность проверить вложение $R\subseteq P$?
Тогда для хранения информации о символах можно реализовать
специальные \emph{версии} rpm-зависимостей~--- т.\,н. set-версии, которые представляют собой захешированные множества символов:
пакет с разделяемой библиотекой предоставляет зависимость вида \verb|Provides: libfoo.so.1 = set:7f0252c3...|,
а пакет, который использует библиотеку, требует зависимость \verb|Requires: libfoo.so.1 >= set:3f5b289c...|

Пусть заданы множества $R$ и $P$, и определен предикат $R\subseteq P$.
\emph{Схемой комплементарного хеширования} мы называем тройку $\langle H_R, H_P, \subseteq^*\rangle$,
состоящую из двух функций хеширования $H_R(R)\to R^*$, $H_P(P)\to P^*$ и
предиката $R^*\subseteq^*P^*$.  При этом если $R\subseteq P$, то должно всегда
выполняться и $R^*\subseteq^*P^*$. А если $R\not\subseteq P$, то $R^*\not\subseteq^*P^*$
выполняется с вероятностью $1-\varepsilon$, где параметр $\varepsilon$ задает одностороннюю ошибку,
обусловленную потерей информации при хешировании.  Односторонний характер ошибки (false positive) означает,
что проверка зависимостей никогда не будет давать ложных срабатываний, но может пропускать некоторые <<настоящие>> ошибки.
Другими словами, в худшем случае проверка не сработает.

Оказывается, комплементарное хеширование в чистом виде невозможно: а именно,
для $\varepsilon\ll\frac{1}{2}$ нельзя придумать хеш фиксированной длины.
Поскольку размер <<хеша>> растет пропорционально числу элементов множества,
то можно кодировать каждый элемент отдельно, используя 16--32-битный хеш;
а затем рассмотреть процедуру более эффективной упаковки элементов.
Таким образом, мы приходим к следующему представлению множеств:
\begin{verbatim}
P: a b c d e f g h i j k l m n o p q r s t u v w x y z
R:   b       f       j   l     o   q r   t u       y
\end{verbatim}
Строчными буквами здесь обозначены <<хеши>> символов~--- числовые значения, полученные при хешировании.
Эти значения располагаются в возрастающем порядке, поэтому методом \emph{слияния} проверку $R\subseteq P$
можно выполнить достаточно быстро~--- за линейное время.

Рассмотрим вопросы вероятности и коллизий.  Если множество $P$ состоит из $n$ элементов,
то при хешировании можно использовать $\left\lceil\log_2n\right\rceil+10$ битов на элемент
(как для элементов $P$, так и для элементов $R$).  Например, если $n=1024$, то можно использовать 20-битный хеш;
будем считать такую конфигурацию типичной.  Тогда вероятность \emph{простой коллизии}, обусловленной ошибкой $\varepsilon$,
составит $2^{10}/2^{20}=2^{-10}\approx0.1\%$.  Другими словами, проверка может не сработать, если требуемый символ
отсутствует, но его хеш совпадает с каким-либо другим имеющимся символом.  Вероятность такой коллизии~--- это
число <<занятых>> элементов $n$ по отношению к общему числу элементов универсума.

Существует еще одна возможность коллизий~--- коллизии внутри самого множества $P$, обусловленные парадоксом
<<дней рождения>>.  При вставке элементов в $m$-битный хеш (т.\,е. по принципу mod $2^m$) первая коллизия
появляется в среднем через $2^{(m+1)/2}$ вставок, а матожидание общего числа попарных коллизиий
после $n$ вставок равно\footnote{Cormen et al., \emph{Introduction to Algorithms} (3rd ed.), p. 133.}
$$E[X]=E\left[\sum_{i=1}^n\sum_{j=i+1}^n{X_{ij}}\right]=\frac{n(n-1)}{2^{m+1}}\approx\frac{n^2}{2^{m+1}}.$$
Другими словами, этот тип коллизий возникает из-за того, что два предоставляемых символа могут иметь
одиниковый хеш.  В типичной конфигурации таких символов должно быть немного: для $n=2^{10}$ и $m=20$ получаем
$E[X]=1/2$.  Но для <<большого>> множества символов $n=2^{16}$ и $m=26$ получаем уже $E[X]=32$ коллизии.
Однако в пересчете на один символ вероятность коллизии составляет
$$\frac{E[X]}{n}\approx\frac{n}{2^{m+1}}=\frac{n}{2^{ \left\lceil\log_2n\right\rceil+11 }}\approx2^{-11}\approx0.05\%.$$
Таким образом, несмотря на то, что число коллизий растет, в пересчете на символ вероятность коллизии <<дней рождения>>
остается невысокой: она <<подчинена>> вероятности простой коллизии.

Рассмотрим теперь вопросы реализации.  Реализация должна быть \emph{практичной},
что в нашем понимании означает две вещи:
\begin{itemize}
\item Нужно получить наиболее короткое представление set-версий.  Другими словами, нужна эффективная процедура
упаковки и сериализации массива из $n$ $m$-битных чисел, причем эффективность прежде всего оценивается по длине
полученной строки: длина строки должна быть близка к информационно-теоретическому минимуму.
\item Распаковка строк и восстановление массива чисел должны выполняться очень быстро.  Другими словами,
требуется эффективная обратная процедура, причем эффективность в данном случае оценивается по времени.
\end{itemize}

Рассмотрим возможность упаковки элементов в типичной конфигурации: набор из 1024 20-битных хешей можно рассматривать
как выбор $2^{10}$ элементов из $2^{20}$ элементов, или же как выбор 1 сочетания из ${2^{20}\choose2^{10}}$ сочетаний.
Чтобы сделать такой выбор, требуется $\log_2{{2^{20}}\choose{2^{10}}}\approx11710$ битов информации (если считать
все сочетания равновероятными).  Таким образом, оптимальный способ упаковки элементов может значительно снизить размера хеша~---
вместо 20 битов на элемент в упакованном виде потребуется примерно 11.44 бита на элемент.
В нашей реализации требуется примерно 1.95 алфавитно-цифровых буквы, или же примерно 11.6 бита на элемент
(разреженные $R$-версии требуют несколько больше~--- например, для упаковки 32 20-битных хешей нужно уже 16.5 битов на элемент,
но экономия все еще заметна).

Упаковка выполняется в несколько этапов:
\begin{itemize}
\item Массив чисел сортируется, дубликаты удаляются.
\item Выполняется \emph{дельта-кодирование}: возрастающая последовательность чисел заменяется
последовательными разностями чисел.
\item К полученной последовательности <<маленьких чисел>> применяется \emph{код Голомба--Райса}:
младшие биты чисел кодируются в обычном бинарном коде, а старшие биты~--- в унарном
коде переменной длины.  Поскольку большинство чисел являются <<маленькими>>, то их унарные
части оказываются короткими.  В результате получается оптимальная\footnote{ Putze et al.,
\emph{Cache-, Hash- and Space-Efficient Bloom Filters},
\url{http://algo2.iti.uni-karlsruhe.de/singler/publications/cacheefficientbloomfilters-wea2007.pdf}}
по длине битовая последовательность, кодирующая массив разностей.
\item Битовая последовательность сериализуется в кодировке <<Base62>>,
то есть, наконец, образуется строка, состоящая из символов набора \verb|0-9A-Za-z|.
\end{itemize}

Несмотря на то, что при распаковке не используется дорогих операций (таких, как деление в цикле),
первоначальная <<наивная>> реализация распаковки работала недостаточно быстро.  Чтобы ускорить распаковку,
были использованы следующие техники оптимизации:
\begin{itemize}
\item Реализована комбинированная стадия распаковки <<Base62>> и Голомба--Райса.
При распаковке строки битовая последовательность не восстанавливается полностью;
вместо этого распакованные биты поступают в конвейер, который сразу формирует массив разностей.
\item На каждом шаге распаковываются сразу две буквы.  Для этого <<кусочки строки>> приводятся к типу \texttt{unsigned short},
и далее используется вспомогательная таблица, которая упрощает обработку <<двухбуквенных значений>> (таблица содержит 65536
элементов, но из них используются только $62\cdot62=3844$, так что таблица хорошо умещается в кэше процессора).
\item Для Provides-версий реализован LRU-кэш.  Кэш содержит 160 слотов и занимает 1.3--2~Мбайт, коэффициент попаданий~--- 67\%.
\end{itemize}
В результате проверка всех версий в репозитории занимает менее 1 с. user time (проверка всех версий выполняется, например,
при обновлении базы \verb|apt|, когда все требуемые версии зависимостей сопоставляются с предоставляемыми версиями).

Отметим еще одну важную особенность реализации.  При обновлении библиотеки число символов может перешагнуть
очередную отметку $2^m$, в результате чего изменится количество битов на символ:
$m_1=\lceil\log_2|P_1|\rceil+10 > m_0=\lceil\log_2|P_0|\rceil+10$.  При этом у пакетов в репозитории
зависимости на библиотеку сформированы со старым значением $m_0$.  Однако благодаря тому, что хеш вычисляется
по принципу mod $2^m$ (т.\,е. фактически берутся младшие биты более длинного хеша), а не по принципу mod prime
(как принято в некоторых других случаях), сравнение версий с несовпадающим количество битов все равно можно выполнить (правда,
с некоторой потерей точности).  Для этого значения в $P_1$ нужно <<подрезать>>, сохранив только $m_0$ битов, и выполнить
повторную сортировку.  При сборке пакетов с новой версией библиотеки $P_1$ формирование зависимостей уже будет выполняться
с параметром $m_1$.  Таким образом, можно считать, что <<выравнивание точности>> зависимостей происходит автоматически,
но с некоторой задержкой.

Попробуем подытожить наши рассуждения.  Мы решили не полагаться на обратную совместимость, а напрямую контролировать
наличие нужных символов в нужных библиотеках.  Для этого мы реализовали вероятностную схему проверки вложения множеств $R\subseteq P$.
Задав достаточно низкую <<посимвольную>> вероятность ошибки $\varepsilon\approx0.1\%$, мы получили относительно короткое представление
set-версий~--- примерно 2 буквы на символ.  Конечно, данное решение является компромиссным, и поэтому уязвимо для критики:
с одной стороны, вероятность ошибки не настолько низкая, чтобы считать, что зависимости дают полную гарантию; с другой стороны,
версии получаются не слишком-то короткими~--- для 1024 символов длина строки будет почти 2 Кбайта.  Вместе с тем, реализация является
во многих отношениях оптимальной, так что серьезно улучшить этот компромисс, по-видимому, невозможно.

\section{Другие методы поиска зависимостей}
Стандартная политика сборки включает в себя более 20 методов поиска зависимостей;
кроме того, имеется более 20 дополнительных методов поиска зависимостей, которые используются
только при сборке определенной группы пакетов.

Основная задача автоматического поиска зависимостей~--- обеспечить работоспособность компонентов ПО.
Для программ условия работоспособности очевидны~--- программа должна запускаться и т.\,п.
В некоторых других случаях, однако, понятие работоспособности нуждается в уточнении.  В таких случаях
лучше говорить о \emph{факторах работоспособности}.  Рассмотрим в качестве примера библиотечные \texttt{devel}
пакеты~--- пакеты со вспомогательными файлами для компиляции и компоновки.  Т.\,к. эти пакеты обычно не нужны
для работы программ, а только для сборки, то возникает вопрос: какие зависимости должны быть у \texttt{devel}
пакетов?  Можно выделить следующие факторы работоспособности \texttt{devel} пакетов:
\begin{itemize}
\item Возможность включения заголовочных файлов.
Если заголовочные файлы в свою очередь включают другие заголовочные файлы, то включение внешних
по отношению к пакету заголовочных файлов должно быть поддержано соответствующими зависимостями.
\item Возможность компоновки с библиотекой.
Файл \verb|libfoo.so|, который используется при компоновке с опцией \verb|-lfoo|, обычно является
символической ссылкой, причем ссылка указывает не на имя библиотеки \verb|libfoo.so.0|, а на файл
c \verb|libtool|-версией \verb|libfoo.so.0.0.0|.  Поэтому обычно \verb|devel| пакет должен содержать
строгую зависимость на пакет с библиотекой.  Однако в некоторых случаях строгая зависимость нежелательна,
и, вообще говоря, возможность компоновки должна быть поддержана зависимостью, которая будет гарантировать,
что символическая ссылка \verb|libfoo.so| указывает на существующий файл.
\item Если в пакете имеется \verb|pkgconfig|-файл \verb|foo.pc|, то зависимости на другие компоненты
подсистемы \verb|pkgconfig|, указанные в поле \verb|Requires| этого файла, должны быть перенесены в зависимости
\verb|devel| пакета.
\item Кроме того, если \verb|pkgconfig|-файл \verb|foo.pc| содержит поле \verb|Libs|, то указанные в этом поле
опции компоновки с внешними библиотеками \texttt{-lbar -lbaz} должны быть поддержаны зависимостями на файлы
\verb|libbar.so| и \verb|libbaz.so|.
\end{itemize}

Из рассмотренного примера ясно, что работоспособность компонентов ПО можно в общем случае понимать
как возможность использовать компоненты по прямому назначению, при этом даже в минимальной конфигурации
не должно возникать ошибок, говорящих о том, что для полноценного использования не хватает каких-либо
других компонентов ПО.

Нежелательными, однако, являются \emph{транзитивные зависимости}: так, в зависимостях нужно учитывть
только те заголовочные файлы, которые включаются напрямую, но не учитывать последующие файлы, которые
включаются <<в свою очередь>>.  Если бы транзитивные зависимости были допустимы, то реализация сводилась бы
к построению \emph{транзитивного замыкания} с помощью \emph{трассировки}: полный список требуемых
файлов можно получить в результате фактической оперции включения.

\subsection{cpp.req}
Итак, можно реализовать довольно смелую идею: формировать зависимости, которые обеспечивают возможность включения
заголовочных файлов, расположенных в каталоге \verb|/usr/include| и подкаталогах, за счет анализа директив \verb|#include|.
Поскольку заголовочные файлы часто содержат условные конструкции и т.\,п., то для анализа нужно использовать
<<родной механизм>>~--- препроцессор \verb|cpp(1)|.  За счет выполнения фактической операции включения (препроцессирование
можно рассматривать как включение на <<нулевом уровне>>) препроцессор позволяет определить список используемых файлов.
Однако, как уже отмечено, к зависимостям следует относить только те файлы из списка, которые были включены непосредственно
(на первом уровне).  К счастью, в директивах для компилятора, которые выводит препроцессор, содержатся не только имена файлов
и номера строк, но и дополнительная информация,\footnote{См. \texttt{info cpp "Preprocessor Output"}}
которая позволяет реконструировать стек включения файлов.  Тогда в зависимостях нужно учитывать только файлы,
которые включаются при пустом стеке.

Существуют, однако, заголовочные файлы, которые не предназначены для непосредственного включения и, более того, содержат защиту
от непосредственного включения.  Например, файл \texttt{/usr/include/gtk-2.0/gtk/gtkaccessible.h} содержит следующую
конструкцию:
\begin{verbatim}
#if !defined (__GTK_H_INSIDE__)
#error "Only <gtk/gtk.h> can be included directly."
#endif
#include <atk/atk.h>
#include <gtk/gtkwidget.h>
\end{verbatim}
Этот файл является <<составной частью>> файла \verb|<gtk/gtk.h>|, а при попытке его непосредственного анализа
работа \verb|cpp(1)| завершится с ошибкой.  В то же время при анализе \verb|<gtk/gtk.h>| будут учтены только
непосредственно включаемые файлы.  Таким образом, зависимость на \verb|<atk/atk.h>| будет потеряна.

Каким образом можно избежать потери зависимостей в таких случаях?  С одной стороны, можно попытаться подавить
директиву \verb|#error|.  С другой стороны, директива \verb|#error| не срабатывает, если включение происходит в файле
\verb|<gtk/gtk.h>|.  Так что лучше будет расширить анализ зависимостей \verb|<gtk/gtk.h>| на стадии реконструкции стека
включений файлов.  А именно, если файл, включенный на первом уровне, является <<внутренним>>, то нужно также учитывать
файлы на втором уровне и т.\,д., вплоть до первого файла на <<внешнем>> уровне.  В нашем примере рассмотренный файл
будет внутренним по отношению к \verb|<gtk/gtk.h>|, а \verb|<atk/atk.h>|~--- первым <<внешним>> файлом, который
и должен учитываться в зависимостях.  Вообще, к <<внутренним>> можно отнести файлы, которые при сборке находятся
в \verb|%buildroot|, хотя более корректная реализация должна учитывать различие между подпакетами.

Итак, с помощью препроцессора удается установить, что директива \verb|#include <atk/atk.h>| приводит к включению
файла \url{/usr/include/atk-1.0/atk/atk.h}.  Использовать файловую зависимость в данном случае
не очень хорошо, потому путь содержит подкаталог с версией, причем подкаталог задан в другом файле~--- \verb|atk.pc|.
Поэтому формируется зависимость на имя пакета \verb|libatk-devel|.

\subsection{pkgconfig.req}
Рассмотрим другие зависимости, характерные для \verb|devel| пакетов: зависимости подсистемы \verb|pkgconfig|.
Эта подсистема часто используется в скриптах \verb|configure| для определения расположения заголовочных файлов и т.\,п.
Во многих дистрибутивах уже используются такие зависимости~--- зависимости вида \verb|pkgconfig(foo)|,
поэтому остановимся только на некоторых особенностях реализации.

В подсистеме \verb|pkgconfig| существуют два типа зависимостей: \verb|Requires| и \verb|Requires.private|.
Смысл зависимостей \verb|Requires| примерно соответствует зависимостям \verb|Requires| в \verb|rpm|,
а зависимости \verb|Requires.private| изначально предназначались для указания компонентов, которые используются
в реализации, но не влияют интерфейс (эти компоненты могут потребоваться для статической компоновки).

В дальнейшем различие между \verb|Requires| и \verb|Requires.private| привело к грандиозной путанице.
Дело в том, что зависимости \verb|Requires| влияют как на включение заголовочных файлов при компиляции (параметр \verb|Cflags|),
так и на подключение библиотек при компоновке (параметр \verb|Libs|).  Во многих случаях, однако, требуется только
включение файлов (для использования макросов и т.\,п), а компоновка с библиотекой приводит к порождению лишней зависимости.
Поэтому появлиась идея использовать для таких случаев зависимости \verb|Requires.private|.
Идея получила некоторое распространение и была узаконена в одной из последних версий \verb|pkg-config|: в режиме
\verb|--cflags| наличие зависимостей \verb|Requires.private| стало обязательным.  Поэтому в некоторых дистрибутивах
стали также учитывать \verb|Requires.private| зависимости~--- фактически, на уровне межпакетных зависимостей различие
между \verb|Requires| и \verb|Requires.private| стерлось.

Мы предлагаем следующее решение этой проблемы:
\begin{itemize}
\item Вопросы компоновки с библиотеками рассмотрены далее в разделе \ref{linkning-with-libraries}.
\item Учитывать нужно только зависимости типа \verb|Requires|.
\item В тех случаях, когда зависимости \verb|Requires.private| используются для подключения заголовочных файлов,
завимости на заголовочные файлы будут сформированы с помощью \verb|cpp.req|.
\item Нужно модифицировать \verb|pkg-config| таким образом, чтобы в режиме \verb|--cflags| зависимости
\verb|Requires.private| считались необязательными: имеющиеся компоненты должны учитываться, а отсутствующие
компоненты не должны приводить к ошибке.
\end{itemize}

\subsection{pkgconfiglib.req}
Этот метод поиска зависимостей анализирует параметр \verb|Libs| в файлах \verb|pkgconfig|.
Для каждой опции компоновки \verb|-lfoo| выполняется поиск библиотеки \verb|libfoo.so| и формируется соответствующая зависимость.
При этом файловая зависимость оказывается не всегда желательной, т.\,к. путь к библиотеке, вообще говоря,
конорлируется через опцию \verb|-L|.  Поэтому, как и в случае с \verb|cpp.req|, формируется зависимость на
имя пакета с библиотекой.

Таким образом, зависимости у \verb|devel| пакетов контролируются двумя способами: зависимости подсистемы
\verb|pkgconfig| отображаются в зависимости вида \verb|pkgconfig(foo)|, а \emph{фактические} зависимости,
связанные с включением заголовочных файлов и компоновкой с библиотеками, представлены именем пакета \verb|libfoo-devel|.
Обычно эти два типа зависимостей должны соответствовать друг другу.  Однако в некоторых пакетах для зависимости
\verb|pkgconfig(foo)| не находится соответствующий зависимости \verb|libfoo-devel|.  Как правило, это означает,
что в \verb|pkgconfig| файле зависимость на \verb|foo| является излишней или ошибочной.

Отметим еще одну особенность реализации: если для получения поля \verb|Libs| использовать \verb|pkg-config(1)|
с опцией \verb|--libs|, то вывод будет <<рекурсивно>> дополнен флагами \verb|Libs| компонентов, указанных
в \verb|Requires|.  Таким образом, напрямую этот вывод использовать нельзя, т\,к. это приведет к образованию
транзитивных зависимостей.  Можно было бы не использовать \verb|pkg-config(1)|, а попытаться извлечь поле \verb|Libs|
другим способом; однако эта задача усложняется из-за того, что поле \verb|Libs| может содержать подстановки переменных.
Поэтому мы предлагаем еще раз модифицировать \verb|pkg-config|: добавить опцию \verb|--disable-reqcursion|, которая
отключает <<рекурсивное>> дополнение флагов.

\subsection{shebang.req}
\label{shebang-req}
Рассмотрим еще несколько более общих методов поиска зависимостей.
Метод \verb|shebang.req| является общим для всех \emph{скриптов}: исполняемых файлов, содержащих в первой строке
инструкцию вида \verb|#!/usr/bin/foo args|.  Для таких файлов порождается зависимость на интерпретатор \verb|/usr/bin/foo|.

Однако в некоторых случаях, когда точный путь к интерпретатору неизвестен, интерпретатор можно вызвать через
программу \verb|env(1)|, т.\,е. с помощью инструкции вида \verb|#!/usr/bin/env foo|.  В таких случаях дополнительно
выполняется поиск команды \verb|foo| c помощью того же механизма, который используется при формировании зависимостей
для команд в шелл-скриптах (см. раздел \ref{shell-req}).

Кроме того, \verb|shebang.req| выполняет проверку инструкций указанного вида и позволяет обнаружить некоторые типичные ошибки.
Во-первых, ошибочным можно считать использование окончаний строк \verb|\r\n|, т.\,к. символ \verb|\r| в первой строке
не будет удален.  Более того, если инструкция вызова интерпретатора не содержит аргументов, то скрипт даже не сможет
запуститься, т.\,к. файл \verb|/usr/bin/foo\r| не существует.  В таких случаях работа \verb|shebang.req| завершается с ошибкой,
что также должно привести к ошибочному завершению сборки пакета.

Во-вторых, при вызове интерпретатора с аргументами \verb|#!/usr/bin/foo args| на самом деле не выполняется
полного разбиения аргументов \verb|args|, т.е. \verb|args| передается в виде одного аргумента, даже если в нем содержатся
пробелы.  Некоторые интерпретаторы <<знают>> о том, при запуске скрипта нужно выполнять дополнительное разбиение
аргументов.  Так, \verb|perl(1)| прекрасно справляется с инструкцией \verb|#!/usr/bin/perl -w -T|.  Однако
команда \verb|env(1)| не выполняет дополнительного разбиения аргументов.  Поэтому инструкции вида \verb|#!/usr/bin/env perl -w|
являются ошибочными: такие скрипты нельзя будет запустить (в данном случае работа скрипта завершится с ошибкой
\texttt{/usr/bin/env: perl -w: No such file or directory}).  В таких случаях работа \verb|shebang.req|
также завершается с ошибкой.

\subsection{files.req}
\label{files-req}
Этот метод поиска зависимостей позволяет формировать зависимости на каталоги, в которых расположены файлы.

Рассмотрим для примера зависимости perl-модулей.  Пакет, котрый содержит модуль \verb|Foo.pm|,
должен предоставлять зависимость \texttt{Provides: perl(Foo.pm)}.  Однако эта предоставляемая зависимость
напрямую свазана с файлом \texttt{/usr/share/perl5/Foo.pm}, расположенном в иерархии \verb|/usr/share/perl5|.
Если интерпретатор не поддерживает иерархию \verb|/usr/share/perl5| (не выполняет поиск модулей в этом каталоге),
то он не сможет загрузить этот модуль.  В таком случае мы не имеем права предоставлять <<логическую>> зависимость
\verb|perl(Foo.pm)|, не обеспечив требования <<физической>> согласованности с интерпретатором.

Требования соласованности виртуальных зависимостей с поддерживаемыми иерархиями каталогов можно довольно
удачно выразить с помощью файловых зависимостей на каталоги: в рассмотренном примере пакет должен быть
дополнен зависимостью \texttt{Requires: /usr/share/perl5}.  Для разрешения такой зависимости достаточно,
чтобы каталог \verb|/usr/share/perl5| <<принадлежал>> интерпретатору, т.\,е. чтобы этот каталог был
запакован в базовом пакете \verb|perl-base|.  Если же интерпретатор не поддерживает каталог \verb|/usr/share/perl5|,
то для установки модуля потребуется обновление интерпретатора.

Однако такая схема зависимостей является довольно хрупкой: если какой-либо другой пакет по ошибке <<завладеет>>
каталогом \verb|/usr/share/perl5|, то проверка согласованности через зависимость на каталог потеряет смысл.
Поэтому нужно дополнительно контролировать эксклюзивную принадлежность каталогов, образующих иерархии,
к своим базовым пакетам.

Метод \verb|files.req| позволяет решить обе задачи: формировать зависимости на каталоги и контролировать
эксклюзивную принадлежность каталогов.  Для этого используются конфигурационные файлы \url{/usr/lib/rpm/*-files.req.list},
содержащие пары $\langle\textit{каталог},\textit{базовый-пакет}\rangle$.  Так, файл \url{/usr/lib/rpm/perl-files.req.list}
содержит строки
$\langle\texttt{/usr/lib64/perl5},\texttt{perl-base}\rangle$,
$\langle\texttt{/usr/share/perl5},\texttt{perl-base}\rangle$.
Если какой-либо файл в пакете располагается в одном из этих каталогов (или их подкаталогах),
то \verb|files.req| формирует зависимость на каталог.  Кроме того, \verb|files.req| выдает предупреждение,
если пакет содержит сам каталог, и при этом пакет назывется не \verb|perl-base| (после сборки пакета
другая программа выполняет более строгую проверку, которая может завершиться с ошибкой).

\subsection{symlinks.req}
\label{symlinks-req}
Этот метод формирует зависимости для символических ссылок.  Каждая символическая ссылка в пакете
должна указывать на существующий файл (либо на другую символическую ссылку, которая в свою очередь
должна указывать на существующий файл и т.\,д.).  Значение символической ссылки считывается и выполняется
один шаг разрешения пути: в качестве зависимости выступает путь, на который указывает ссылка.
При этом каноникализация путей выполняется средствами процедуры \verb|find-package| (см. раздел \ref{file-deps}).
Следует также отметить, что б\'{о}льшая часть полученных зависимостей впоследствии будет оптимизирована
(см. раздел \ref{deps-optimization})~--- будут сохранены только зависимости для ссылок на <<внешние>> файлы.

\subsection{rpm-build-mono}
\label{rpm-build-mono}

\section{Зависимости \%post-скриптов}

\label{post-script-deps}

\section{Фильтрация зависимостей, weak provides}
\label{filter-deps}

\section{Подпакеты с отладочной информацией}

\label{debuginfo-subpackages}

\section{Проверки во время сборки пакетов}

\label{brp-verify}

\section{Разное}

\subsection{rpm4 vs rpm5}

\subsection{multiarch}

\subsection{компоненты rpm-build}

\subsection{Файлтриггеры}

\subsection{Компоновка с библиотеками}
\label{linkning-with-libraries}

\end{document}
