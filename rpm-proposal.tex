\documentclass[russian,a4paper,12pt,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{fullpage}
\usepackage{url}

\sloppy
\hyphenpenalty=666

\begin{document}
\title{Предложения по развитию\\системы управления пакетами RPM}
\author{Алексей Турбин \url{<at@altlinux.org>}}
\maketitle
\tableofcontents
\pagebreak[4]

\section*{Введение}
Ян Мёрдок (основатель проекта Debian) назвал управление пакетами <<самым
выдающимся достижением, которое Linux привнес в IT-отрасль>>.\footnote{\textit{The
single biggest advancement Linux has brought to the industry.}
\url{http://ianmurdock.com/solaris/how-package-management-changed-everything/}}
Мёрдок отмечает, в частности, возможность унифицированного обновления ПО по сети,
а также модель распределенной разработки, которая стала возможна благодаря разбиению
операционной системы на компоненты.

Нужно заметить, однако, что возможность обновления пакетов по сети
реализуется в виде надстройки (apt, yum) над базовым уровнем управления пакетами
(rpm, deb), тогда как модель распределенной разработки является не столько техническим,
сколько социальным аспектом разработки свободного ПО.  В то же время функции, реализуемые
на базовом уровне управления пакетами, подозрительно похожи на функции архиватора типа tar,
который существовал в UNIX всегда.
Действительно, rpm-пакеты можно рассматривать как <<тарболлы>>, а rpm~--- как
некоторое подобие tar (по крайней мере, в части установки пакетов).  Более того,
в некоторых системах <<тарболл>> и является основным форматом пакетов.  Возникает
вопрос: каковы главные особенности системы управления пакетами на базовом уровне,
делающие её принципиально отличной от архиватора?  Что можно считать
<<достижением>> на базовом уровне?

На первый взгляд, главным отличием rpm от архиватора является возможность обновления и удаления пакетов.
В отличие от обычного архиватора, rpm поддерживает базу пакетов \verb|rpmdb|, в которой хранится информация
об установленных пакетах и о файлах, ассоциированных с пакетами.  При обновлении пакетов эта информация
позволяет корректно выполнить замещение файлов и т.\,п.  Впрочем, нужно понимать, что некоторая сложность,
связанная с корректным замещением файлов, возникает вследствие использования традиционной иерархии файловой
системы, при которой файлы в зависимости от их назначения располагаются в разных системных каталогах.
Некоторые разработчики считают традиционную иерархию файловой системы слишком сложной.
Так, в дистрибутиве GoboLinux выполнена полная реорганизация файловой системы: каждому пакету отводится
собственный подкаталог в системном каталоге \verb|/Programs|.  Это радикально упрощает обновление пакетов,
сводя его к удалению старого каталога и распаковке нового архива.

На наш взгляд, принципальное отличие управления пакетами от <<управления тарболлами>> состоит в другом.
Архиватору безразлично содержимое файлов в архиве, распаковка~--- это его единственная функция; сохранность
байтов~--- это всё, что его в принципе интересует.  В то же время перед rpm стоит более сложная задача:
поддержка операционной системы в целостном, согласованном состоянии.  Фактически, базовый уровень
управления пакетами должен гарантировать работоспособность операционной системы (в той степени,
в которой это вообще возможно) и обеспечивать совместимость установленных компонентов ПО.  Возможность
обновления ПО по сети, отмеченную Мёрдоком, можно интерпретировать именно так~--- как поддержку ОС
в актуальном рабочем состоянии.

Таким образом, можно сказать, что базовый уровень управления пакетами является <<достижением>> настолько,
насколько он \textit{не сводится} к функциям архиватора.  В частности, в какой-то момент система управления
пакетами должна весьма сильно интересоваться содержимым файлов, входящих в пакет, т.\,к. работоспособность
операционной системы и совместимость компонентов ПО могут быть во многих случаях объяснены в терминах
содержимого тех или иных файлов.  Если же не интересоваться содержимым файлов, то гарантировать их согласованную
совместную работу, по-видимому, никак нельзя.

В rpm основным способом описания работоспособности и совместимости пакетов являются \textit{зависимости}.
При сборке пакетов rpm изучает содержимое файлов, входящих в пакет, и формирует зависимости пакета.
Зависимости Requires описывают требования, которые предъявляются к другим пакетам.  Зависимости Provides
в свою очередь описывают <<предоставляемые>> свойства пакета, которые могуть быть <<затребованы>> через
Requires в других пакетах.  Соответственно, в rpm имеются вспомогательные программы \verb|find-requires|
и \verb|find-provides|, которые выполняют поиск Requires и Provides зависимостей.  Эти две программы
составляют основу \textit{подсистемы автоматического поиска зависимостей} (эта подсистема также может быть
использована для автоматического поиска зависимостей типа \verb|Reqires(post)| в \%post-скриптах,
о чем подробнее в разделе \ref{post-script-deps}).  Большая часть данного документа посвящена
усовершенствованию этой подсистемы.  Как будет видно в дальнейшем, многие требования работоспособности
и совместимости пакетов могут быть описаны гораздо более точно (так, в разделе \ref{set-versions} описан
способ компактного представления множества символов, с помощью которого можно в значительной степени
решить проблему т.\,н. <<dll hell>>~--- проблему версионирования и неполной совместимости разделяемых библиотек).

Интересно отметить <<асимметричный>> характер системы управления пакетами на базовом уровне: содержимое
файлов изучается только во время сборки пакетов для формирования зависимостей.  На стадии же установки
rpm руководствуется зависимостями, полученными при сборке; а содержимое файлов его снова не интересует.
В терминах дихотомии Эрика Реймонда\footnote{\textit{Rule of Separation: Separate policy from mechanism;
separate interfaces from engines.} \url{http://www.faqs.org/docs/artu/ch01s06.html}}
можно сказать, что при установке пакетов работает базовый \textit{механизм}, тогда как \textit{политика}
управления пакетами на самом деле осуществляется во время сборки.

Политика сборки пакетов не обязательно должна ограничиваться анализом файлов для формирования зависимостей.
Можно реализовать более агрессивную политику сборки, направленную, во-первых, на автоматическую коррекцию содержимого
пакетов, а во-вторых, на процедуры автоматической верификации, которые должны быть выполнены, чтобы пакет успешно собрался.
Эти процедуры могут выполняться, в частности, на стадии brp (buildroot policy).  Примером коррекции содержимого
пакетов является процедура brp-debuginfo, которая используется для подготовки пакетов с отладочной информацией (см. раздел
\ref{debuginfo-subpackages}).  Некоторые процедуры автоматической верификции рассмотрены в разделе \ref{brp-verify}.

Однако не все проверки стоит выполнять при сборке пакета.  Некоторые проверки
являются специфическими для дистрибутива и поэтому не могут быть частью базовой
политики сборки пакета (например, сюда можно отнести формальное требование указывать
в \%changelog <<официальный>> e-mail адрес, связанный с проектом).  Другие проверки не требуют
доступа к содержимому файлов~--- например, проверка на соответствие FHS (filesystem hierarchy standard).
Другой пример: архитектурно-независимые пакеты (noarch) не должны содержать архитектурно-зависимых путей
(файлов в каталоге \verb|/usr/lib64| и подкаталогах).  Такие проверки можно оформить в виде отдельной программы
типа rpmlint.

Между прочим, последняя проверка является в некотором смысле недостаточной: не только в noarch пакетах не должно быть
архитектурно-зависимых путей, но и вообще при сборке на любой архитектуре должны получаться идентичные noarch пакеты.
Таким образом, выполнение такой проверки потребует синхронной сборки пакета на двух (или более) архитектурах, т.е.
она не может быть реализована на уровне rpm, а только на уровне сборочной системы (если сборочная система синхронизирует
сборку для нескольких архитектур).  В сборочной системе одного российского дистрибутива реализована именно такая~--- достаточно
строгая~--- политика верификации noarch пакетов.

Мы завершаем введение кратким обзором сборочной системы.\footnote{Подробнее см. \textit{Сборочная система git.alt}
в сборнике \url{http://www.altlinux.ru/media/book-thesis-Protva-2008-5.pdf}}  Приоритетной задачей сборочной системы
является автоматическое тестирование и верификация пакетов во время и после сборки, т.\,е. политика сборки, направленная
на поддержку целостности репозитория пакетов (в то время как, например, наличие веб-интерфейса для нас не представляет интереса).
Сборочная система характеризуется относительно высоким процентом отказов в приеме пакетов (при обнаружении дефектов в пакетах).
В то же время сборочная система работает полностью автоматически, и пакеты без дефектов поступают в репозиторий сразу же (проверка
вручную и дополнительное тестирование могут быть организованы перед синхронизацией репозитория на основной публичный сервер).

Политику сборочной системы можно описать в терминах \textit{формальной модели}: поступление новых пакетов моделируется
как переход репозитория из состояния $A_0$ в состояние $A_1$.  При этом, в идеале, в любом состоянии должно быть выполнено
формальное условие, которое можно назвать \textit{инвариантом перехода}: все пакеты должны успешно проходить тестовую пересборку,
и все пакеты должны успешно устанавливаться в базовую среду (basesystem).  В реальности контролировать инвариант перехода
удается лишь частично, т.\,к. тестовая пересборка всех пакетов требует довольно много вычислительных ресурсов.
Как следствие, нереализованной остается принципиально важный компонент сборочной системы~--- \textit{метарепозиторий},
который позволил бы учитывать взаимное влияние между пакетами и, в частности, контролировать изменение свойств пакета
после тестовой пересборки (а не только сам факт пересобираемости).

Интерфейс сборочной системы позволяет формировать \textit{задания} на сборку.  Задание может содержать несколько
пакетов, которые собираются в строгой последовательности (без изменения основного репозитория).  После этого моделируется
переход $A_0\to A_1$ и, если переход разрешен, задание \textit{транзакционно} применяется к репозиторию.  Таким образом,
сборочная система позволяет проводить несовместимые изменения~--- такие, как изменение soname библиотеки~--- при условии
синхронной пересборки (в этом же задании) всех несовместимых/зависимых пакетов.

К недостаткам сборочной системы можно отнести некоторые ограничения на возможность параллельной сборки,
т.\,к. параллельные переходы не моделируются.

\section{Раскрытие макросов в спекфайле}
\textit{Макросы} в rpm являются базовым механизмом параметризации.  С помощью
макросов можно задать как простейшие текстовые подстановки, так и более сложные
(в том числе рекурсивные) подстановки с аргументами.  В спекфайле <<вызов>> макроса
выполняется с помощью конструкций \verb|%{name}|, \verb|%{name args}| или (в сокращенной записи)
\verb|%name|, \verb|%name args|.

Однако использование макросов сопряжено с некоторой опасностью: когда rpm встречает неизвестный макрос
(т.\,е. одну из конструкций указанного вида, в которой макрос с именем \verb|name| не был заранее определён),
rpm оставляет макрос <<нераскрытым>> (т.\,е. сохраняет конструкцию в незименном виде, как если бы она не считалась
<<вызовом>> макроса).  При этом rpm не выполняет диагностики, с помощью которой можно было бы обнаружить
нераскрытые макросы.  Это порождает целый класс ошибок в пакетах.

Например, в пакете \verb|gnumeric-1.10.17-1-mdv2012.0.x86_64.rpm| содержится следующий \%preun-скрипт:
\begin{verbatim}
SCHEMAS=""
for SCHEMA in %schemas ; do
  SCHEMAS="$SCHEMAS /etc/gconf/schemas/$SCHEMA.schemas"
done
GCONF_CONFIG_SOURCE=`/usr/bin/gconftool-2 --get-default-source` \
/usr/bin/gconftool-2 --makefile-uninstall-rule $SCHEMAS >/dev/null || true
\end{verbatim}
Макрос \verb|%schemas| в этом скрипте остался нераскрытым.  Т.\,к. \%preun-скрипт
выполняется при удалении пакета, то при удалении будет выполнен вызов \verb|gconftool-2|
с неправильными аргументами, который должен завершиться с ошибкой (однако эта ошибка игнорируется
с помощью конструкции \texttt{>/dev/null || true}).

Другой пример: в пакете \verb|stardict-3.0.1-10-mdv2011.0.x86_64.rpm| имеется \%preun-скрипт
\begin{verbatim}
%preun_install_gconf_schemas stardict
\end{verbatim}
При удалении такого пакета возникнет ошибка типа \texttt{fg: no job control} или \texttt{fg: no such job},
т.\,к. интерпретатор \verb|/bin/sh| считает такую синтаксическую конструкцию обращением к фоновому заданию.

Ещё один пример: пакет \verb|squid-3.1.16-1-mdv2012.0.x86_64.rpm| содержит \%postun-скрипт
\begin{verbatim}
/usr/share/rpm-helper/del-user squid $1 squid
%post cachemgr
%postun cachemgr
\end{verbatim}
Природа ошибки в данном случае более тонкая~--- эта ошибка не сводится к простому <<человеческому фактору>>,
к которому можно отнести опечатки в названиях макросов или <<забытые>> макросы.

Таким образом, чтобы обнаружить целый класс ошибок и повысить надёжность сборки пакетов, мы считаем принципильно
важным диагностировать (в том или ином виде) нераскрытые макросы во время сборки.  В дальнейшем также будет показано, что
определения многих макросов, специфичных для некоторой группы пакетов, могут быть вынесены в отдельный файл и находиться
в отдельном пакете (см. раздел \ref{def-macro-files}).  Это открывает ещё одну возможность для появления нераскрытых
макросов: нераскрытые макросы могут появиться из-за нарушения зависимостей или вследствие надостаточных \verb|BuildRequires|
зависимостей у пакетов.  Поэтому, прежде чем выносить макросы в отдельные файлы, необходимо реализовать защиту от ошибок,
к которым это может привести.

Некоторая сложность в реализации проверки на нераскрытые макросы связана с тем, что rpm не делает специального различия
между <<ключевыми словами>> и сокращенной записью макросов (например, rpm позволяет определить макрос с именем \verb|build|,
в результате чего будет нарушена структура спекфайла~-- исчезнет секция \verb|%build|).  Кроме того, некоторые <<ключевые слова>>
являются специфичными для отдельных секций спекфайла (например, атрибут \verb|%ghost| используется только в секции \verb|%files|).
Поэтому в текущей реализации проверка выполняется немного по-разному в зависимости от секции спекфайла (проверка реализована
на уровне функции \verb|parseSpec|).

Как уже было сказано, если определения макросов, используемых в спекфайле, содержатся в отдельном пакете,
то в спекфайл должна быть добавлена зависимость \verb|BuildRequires| на этот пакет.  Однако, чтобы извлечь эту зависимость,
нужно распарсить спекфайл, который содержит нераскрытые макросы.  Поэтому желательно реализовать два режима
проверки: строгий и мягкий.  В \textit{строгом} режиме работа rpm завершается с ошибкой, если нераскрытые макросы обнаружены
по крайней мере в некоторых секциях спекфайла (таких как \%post-скрипты).  Строгий режим используется по умолчанию при сборке пакета.
В \textit{мягком} режиме ошибки заменяются на предупреждения, что позволяет распарсить спекфал и извлечь зависимости.

\section{Оптимизация зависимостей}
Большая часть предложений в данном документе направлена на совершенствование зависимостей у пакетов;
в том числе предполагается реализация новых типов зависимостей.  Зависимостей станет много.  Это не только
увеличивает размер пакетов, но и повышает нагрузку на сборочную систему, увеличивает время, необходимое
для проверки зависимостей при установке пакетов и т.\,п.  Поэтому, прежде чем добавлять новые~--- полезные~---
зависимости, необходимо рассмотреть способы оптимизации лишних зависимостей~--- зависимостей, которые можно
считать бесполезным.

Прежде всего, можно реализовать \textit{слияние} <<похожих>> зависимостей внутри отдельно взятого подпакета.
Например, зависимость с версией \verb|Provides: foo = 1.0| делает ненужной зависимость без версии \verb|Provides: foo|,
а из двух зависимостей с версиями \verb|Requires: bar >= 1.0| и \verb|Requires: bar >= 2.0| можно оставить только
одну~--- в данном случае с наибольшей версией.  В общем виде, с учетом всевозможных атрибутов зависимостей,
алгоритм слияния может быть довольно сложным.

Однако главным источником лишних зависимостей являются автоматически сгенерированные зависимости \verb|Requires|,
которые могут быть разрешены внутри своего подпакета в соответствующие зависимости \verb|Provides|.  Это
связано с тем, что скрипты геренации зависимостей \verb|Requires| обычно не учитывают то, что некоторые
из этих зависимостей предоставляются тем же самым пакетом (и поэтому всегда будут удовлетворены).
Вместо того, чтобы модифицировать скрипты генерации зависимостей, лучше реализовать глобальную оптимизацю:
исключать из пакета зависимости Requires, которые удовлетворяются зависимостями Provides в этом же пакете.
Эта оптимизация, однако, не может быть распространена на зависимости c некоторыми флагами типа \verb|Requires(pre)|~---
опять же, корректная реализация должна учитывать всевозможные специальные случаи.

В качестве примера рассмотрим зависимости пакета \verb|perl-XML-SAX-0.960.0-2-mdv2011.0.noarch.rpm|.
\begin{verbatim}
Requires: perl(XML::SAX::PurePerl::DTDDecls)
Requires: perl(XML::SAX::PurePerl::DocType)
Requires: perl(XML::SAX::PurePerl::EncodingDetect)
Requires: perl(XML::SAX::PurePerl::Productions)
...
Provides: perl(XML::SAX::PurePerl::DTDDecls)
Provides: perl(XML::SAX::PurePerl::DebugHandler)
Provides: perl(XML::SAX::PurePerl::DocType)
Provides: perl(XML::SAX::PurePerl::EncodingDetect)
Provides: perl(XML::SAX::PurePerl::Exception)
Provides: perl(XML::SAX::PurePerl::Productions)
...
\end{verbatim}
Большую часть \verb|Requires| зависимостей в этом пакете следует отнести к лишним зависимостям~---
а именно, почти все зависимости вида \verb|perl(XML::SAX::...)|.

Оптимизация зависимостей может не ограничиваться зависимостями в пределах одного подпакета:
оптимизацию можно распространить на подпакеты, собираемые из одного исходного пакета, в том случае,
если подпакеты связаны строгой зависимостью.  \textit{Строгой зависимостью} мы называем зависимость
вида \verb|Requires: %name = %version-%release|, которая требует базовый подпакет с указанием не
только версии, но и релиза (номера сборки).  Тогда, если сборочная система не принимает пакеты
без последовательного увеличения либо версии, либо релиза, то можно считать, что строгая зависимость
уникально идентифицирует базовый подпакет.

Идея оптимизации состоит в том, что наличие строгой зависимости позволяет
оптимизировать некоторые другие~--- нестрогие~--- зависимости.  В качестве пример
рассмотрим зависимости пакета \verb|bzip2-1.0.6-3-mdv2011.0.x86_64.rpm|.
\begin{verbatim}
Requires: lib64bzip2_1 = 1.0.6-3
Requires: libbz2.so.1()(64bit)
Requires: libc.so.6()(64bit)
\end{verbatim}
Здесь первая зависимость является строгой~--- она уникально идентифицирует базовый подпакет с библиотекой сжатия.
В таком случае можно упразднить вторую зависимость~--- на soname библиотеки (эта зависимость предоставляется
базовым подпакетом, на который уже имеется строгая зависимость).

Вообще, если пакет \verb|%name-foo| содержит строгую зависимось на некоторый подпакет \verb|%name-base|,
то это позволяет удалить из пакета \verb|%name-foo| два рода \verb|Requires| зависимостей:
\begin{itemize}
\item Зависимости, которые \textit{представляются} пакетом \verb|%name-base|; или же, несколько точнее,
зависимости, которые могут быть удовлетворены \verb|Provides| зависимостями пакета \verb|%name-base|.
\item Зависимосте, которые \textit{уже требуются} пакетом \verb|%name-base|; или же, несколько точнее,
зависимости, которые могут быть подчинены \verb|Requires| зависимостям пакета \verb|%name-base|
в смысле возможности слияния.
\end{itemize}
В примере с \verb|bzip2| зависимость \verb|Requires: libc.so.6()(64bit)| относится к зависимостям второго рода
(базовый подпакет \verb|lib64bzip2_1| содержит такую же зависимость).

Некоторую сложность при оптимизации зависимостей второго рода связана с возможностью строгих \textit{циклических}
зависимостей.  \textit{Наивная} оптимизация зависимостей второго рода может привести к полному~--- <<циклическому>>~---
удалению зависимостей у подпакетов, которые образуют цикл.

Строгие зависимости между подпакетами можно наделить \textit{транзитивностью}: если подпакет \verb|foo| содержит
строгую зависимость на подпакет \verb|bar|, а подпакет \verb|bar| содержит строгую зависимость на подпакет \verb|baz|,
то можно считать, что подпакет \verb|foo| содержит строгую зависимость на пакет \verb|baz| (и оптимизировать зависимости
пакета \verb|foo| не только относительно пакета \verb|bar|, но и \verb|baz|).

Может возникнуть вопрос: в какой степени строгие зависимости действительно являются строгими?
Не стоит ли реализовать ещё более строгие зависимости типа \verb|build-id|, которые идентифицируют пакет по его содержимому?
Можно указать два сценария, при которых строгие зависимости оказываются недостаточно строгими:
\begin{itemize}
\item Какой-либо посторониий пакет пердоставляет зависимость вида \verb|Provides: %name = %version-%release| и,
таким образом, удовлетворяет строгую зависимость Requires.
\item Сборка пакета выполняется без увеличения релиза (возможно, для другого дистрибутива), и возникает два набора пакетов.
Строгие зависимости не предотвращают <<перемешивания>> пакетов из обоих наборов.
\end{itemize}
В обоих случаях оптимизация зависимостей может оказаться некорректной, т.\,к. оптимизация выполняется в предположении,
что строгая зависимость уникально идентифицирует базовый пакет и его зависимости (а оказывается, что базовый пакет можно <<подменить>>).

На наш взгляд, возможность подмены базового пакета является скорее гипотетической, и на практике строгие зависимости
можно считать достаточно строгими.  Существует, однако, один дефект в реализации rpm, который может сделать строгие
зависимости менее строгими: сравнение версий у зависимостей выполняется таким образом, что зависимость вида
\verb|Provides: foo = %version| (с версией, но без релиза) удовлетворяет любую зависимость вида
\verb|Requires: foo = %version-%release| (с такой же версией и с релизом).
По-видимому, алгоритм сопоставления зависимостей в rpm должен быть скорректирован.

\section{Модульная система поиска зависимостей}
На последних стадиях сборки пакета выполняется автоматический поиск зависимостей:
rpm запускает скрипты \verb|find-requires| и \verb|find-provides|, которые анализируют
содержимое файлов в пакете и формируют соответственно \verb|Requires| и \verb|Provides| зависимости.

Почти во всех дистрибутивах скрипты \verb|find-requires| и \verb|find-provides| являются
монолитными программами, т.\,е. добавление новых типов зависимостей требует непосредственной модификации
этих скриптов.  Задача \textit{модульной системы поиска зависимостей}\footnote{См. также
\textit{Автоматический поиск зависимостей в rpm-пакетах} в сборнике
\url{http://www.altlinux.ru/media/protva4.pdf}}
состоит в том, чтобы для каждого типа зависимостей выделить соотвествующие программы поиска зависимостей
и сделать возможным независимое добавление зависимостей новых типов.  В скриптах \verb|find-requires| и \verb|find-provides|
должен остаться только вспомогательный код диспетчеризации.

Рассмотрим фрагмент монолитного скрипта \verb|find-requires|:
\begin{verbatim}
# --- Grab the file manifest and classify files.
exelist=`echo $filelist | xargs -r file | \
        grep -Ev ":.* (commands|script)[, ]" | \
        grep ":.*executable" | cut -d: -f1`
scriptlist=`echo $filelist | xargs -r file | \
        grep -E ":.* (commands|script)[, ]" | cut -d: -f1`

# --- Executable dependency sonames.
  for f in $exelist; do
    [ -r $f -a -x $f ] || continue
    lib64=`if file -L $f 2>/dev/null | \
        grep "ELF 64-bit" >/dev/null; then echo "$mark64"; fi`
    ldd $f | awk '/=>/ {
        if ($1 !~ /libNoVersion.so/ && $1 !~ /4[um]lib.so/) {
            gsub(/'\''"/,"\\&",$1);
            printf "%s'$lib64'\n", $1
        }
    }'
  done | xargs -r -n 1 basename | sort -u
\end{verbatim}
Данную схему поиска зависимостей можно описать так: сначала rpm классифицирует
все имеющиеся файлы и формирует разные категории файлов~--- \textit{отбирает} файлы
для поиска зависимостей, причем основным инструменом классификации является утилита \verb|file(1)|.
Затем для каждой группы выполняется анализ файлов и формируются соответствующие зависимости (в
приведенном фрагменте отбираются исполняемые программы и с помощью \verb|ldd(1)| определяются
разделяемые библиотеки, необходимые для запуска этих программ).

Скрипт \verb|find-requires| можно сделать модульным, если для каждого типа зависимостей выделить
две программы: программу \textit{отбора} файлов и программу \textit{анализа} файлов.  Тогда после реорганизации
работу скрипта \verb|find-requires| можно пояснить следующим образом:
\begin{itemize}
\item Утилита \verb|file(1)| запускается только один раз~--- в скрипте \verb|find-requires|.  Таким образом,
скрипт \verb|find-requires| формирует список файлов и их <<типов>>.  Дальнейшая работа \verb|find-requires|
сводится к вызову программ поиска зависимостей.  Для определенности будем рассматривать зависимости на разделяемые библиотеки.
\item Первая программа~--- с именем \verb|lib.req.files|~--- по списку файлов и их <<типов>> отбирает файлы,
которые содержат зависимости на разделяемые библиотеки.  Список отобранных файлов возвращается в \verb|find-requires|.
\item Затем \verb|find-requires| запускает вторую программу~--- с именем \verb|lib.req|~--- которая выполняет
анализ отобранных файлов и формирует список зависимостей на разделяемые библиотеки.
\end{itemize}

\textit{Модульность}\label{modular-approach} данной схемы состоит в том,
что \verb|find-requires| запускаются все имеющиеся программы поиска зависимостей
(по шаблону \verb|*.req.files| и \verb|*.req|) из каталога \verb|/usr/lib/rpm|.  Скрипт \verb|find-provides| работает аналогична
(запускаются программы с суффиксом \verb|.prov| вместо \verb|.req|).  Таким образом, для добавления нового типа зависимостей
нужно написать четыре программы: программу отбора файлов и программу анализа файлов, соответственно для Requires и Provides.

Другим аспектом модульности является возможность, в дополнение к новому типу зависимостей, реализовать макросы,
предназначенные для некоторой группы пакетов.  Как правило, такие макросы используются для того, чтобы упростить
сборку и унифицировать некоторые конструкции в спекфайлах (см. макросы для perl-пакетов в разделе \ref{perl-macros}).
Макросы также могут использоваться для того, чтобы управлять некоторыми параметрами сборки.

Макросы могут располагаться в отдельных файлах и подключаться по такому же модульному принципу.
Рассмотрим два вида файлов с макросами~--- файлы с суффиксом \verb|.def| и файлы с суффиксом \verb|.env|.
Файлы с суффиксом \verb|.def|\label{def-macro-files} являются традиционными файлами определения макросов.  Например,
в файле \verb|perl.def| определен следующий макрос, который позволяет в <<императивном стиле>> задать дополнительные
каталоги для perl-модулей:
\begin{verbatim}
%add_perl_lib_path()  %global _perl_lib_path %{?_perl_lib_path} %*
\end{verbatim}

У файлов с суффиксом \verb|.def| другое назначение~--- они позволяют <<вклиниваться>> в некоторые стадии сборки пакетов
с достаточно произвольным кодом, который генерируется с учетом текущего макроконтекста в спекфайле.
Например, в файле \verb|perl.env|\label{perl-env-intro} имеется следующая строка:
\begin{verbatim}
%{?_perl_lib_path:export RPM_PERL_LIB_PATH="%_perl_lib_path"}
\end{verbatim}
Таким образом, если в спекфайле был задан макрос \verb|_perl_lib_path|, то его значение экспортируется
в виде перменной окружения \verb|RPM_PERL_LIB_PATH|.  В дальнейшем значение этой переменной учитыватеся
в скриптах поиска зависимостей \verb|perl.req| и \verb|perl.prov|.

\section{Файловые зависимости и процедура find-package}
\textit{Файловыми зависимостями} мы называем зависимости вида \verb|Requires: /usr/foo|,
в~которых в качестве имени зависимости используется путь к файлу (или каталогу).  В rpm реализована
полная поддержка файловых зависимостей.  А именно, файловая зависимость может быть удовлетворена двумя способами:
\begin{itemize}
\item Если пакет предоставляет соответствующую зависимость \verb|Provides: /usr/foo|.
\item Если в пакете запакован файл (или каталог) \verb|/usr/foo|.
\end{itemize}
Таким образом, преимуществом файловых зависимостей является то, что их не нужно явно <<предоставлять>>~---
они предоставляются <<по факту>> наличия файлов в пакете.  Исключением являются <<альтерантивы>>, то есть
символические ссылки, создаваемые при установке программой \verb|update-alternatives| (такие пути должны
быть предоставлены через \verb|Provides|).

Другим преимуществом файловых зависимостей является то, что во многих случаях они являются наиболее точным
выражением \verb|Requires| зависимостей.  Например, если в каком-либо perl-скрипте имеется shebang-инструкция
\verb|#!/usr/bin/perl|, то работоспособность такого скрипта напрямую зависит от наличия интерпретатора \verb|/usr/bin/perl|.
Вместо зависимости на \verb|/usr/bin/perl| можно было бы указать зависимость на пакет \verb|perl-base| (или \verb|perl|,
если в дистрибутиве нет пакета \verb|perl-base|), но такая зависимость оказалась бы менее точной, т.\,к. она не гарантирует
напрямую наличие интерпретатора \verb|/usr/bin/perl| (кроме того, как уже видно, не всегда можно установить однозначное
соответствие между интерпретатором и именем пакета).

Хуже того, при сборке некоторых пакетов генерируются shebang-инструкция с указанием версии интерпретатора: \verb|#!/usr/bin/perl5.14.2|.
Если вместо файловой зависимости для такой инструкции сгенерировать зависимость на \verb|perl-base|, то такая зависимость
окажется не только неточной, но и очень хрупкой.  Зададимся вопросом: что будет при обновлении perl до новой версии?
Если была сгенерирована файловая зависимость, то при обновлении у пакетов с такой инструкцией появится неудовлетворенная
зависимость (и пакеты нужно будет пересобрать).  Если же сгенерировать зависимость на имя пакета, то обновление пройдёт
без нарушения зависимостей, но пакеты утратят работоспособность~--- скрипты перестанут запускаться ввиду отсутствия
интерпретатора!  А это, в некотором смысле, самое плохое, что может случиться~--- получаются, что зависимости, которые
должны давать хотя бы минимальную гарантию работоспособности программы, на самом деле не дают и минимальной гарантии.

Таким образом, мы считаем, что файловые зависимости использовать не только уместно, но и необходимо во всех случаях,
когда зависимость может быть однозначно выражена в виде пути к файлу.

Хотя rpm полностью поддерживает файловые зависимости на базовом уровне (на уровне проверки зависимостей),
некоторые системы на основе rpm не поддерживают файловые зависимости как следует~--- не учитывают того,
что файловые зависимости могут разрешаться через обычные файлы, а не только через \verb|Provides|.
Дело в том, что при работе с репозиторием пакетов общий список файлов во всех пакетах может оказаться
довольно большим, и его обрабтка представляет некоторую сложность.  Рассмотрим два характерных случая:
\begin{itemize}
\item Система доступа к репозиторию вообще не учитывает файлов, запакованных в пакете, а учитывает только явные \verb|Provides|.
В системах такого рода нужно либо добавить <<распознавание>> файлов, либо вместо этого добавлять некоторые файловые пути прямо
в \verb|Provides|.  Однако, например, \verb|apt-rpm| изначально поддерживает файловые зависимости, так что для корректной работы
не требуется модификации клиентских программ.
\item Файловые зависимости не учитываются при <<индексировании>> репозитория, т.\,е. список файлов игнорируется при создании
метаинформации.  Как ни странно, этот случай характерен для \verb|apt-rpm|, и в одном российском дистрибутиве пришлось довольно
серьезно переделать процедуру генерации репозитория.  В таких системах порождение метаинформации должно выполняться в два
прхода: на первом проходе надо искать файловые зависимости, чтобы на втором проходе сохранить частичные списки файлов.
\end{itemize}
В связи с генерацией репозитория нужно учитывать ещё один важный случай:
\begin{itemize}
\item Последовательная оверлейная сборка пакетов.  Пусть мы собираем пакеты на репозитории с корректной, но частичной
поддержкой файловых зависимостей.  Собранные пакеты помещаются в оверлейный репозиторий, который также используется
при сборке.  Тогда при сборке пакета A может образоваться файловая зависимость, для разрешения которой не хватает информации
в основном репозитории.  После этого не может быть выполнена сборка пакета B, который требует для сборки пакет A,
т.\,к. пакет A не может быть установлен.  В общем случае поддержка оверлейной сборки (двух и более пакетов) требует,
чтобы основной репозиторий был перегенирирован с полной информацией о файлах (именно такой подход используется в одном
российском дистрибутиве).
\end{itemize}
Итак, сборочная система и система доступа к репозиторию должны как следует поддерживать файловые зависимости.

Файловые зависимости генерируются не только для shebang-инструкций (см. раздел \ref{shebang-req}),
но и, например, при обработке символических ссылок (см. раздел \ref{symlinks-req}).  Для порождения
файловых зависимостей разработана вспомогательная библиотека шелл-функций \verb|/usr/lib/rpm/find-package|.
Изначально библиотека использовалась для анализа зависимостей в шелл-скриптах, поэтому основная процедура
\verb|FindPackage| на самом деле используется как для порождения файловых зависимостей, так и зависимостей
для \textit{команд}, т.\,е. для программ, вызываемых по имени (без указания полного пути программы).

Про порождении файловых зависимостей в \verb|find-package| выполняется \textit{канониклизация} пути.
При этом должны быть учтены некоторые особенности сопоставления путей в каталоге \verb|%buildroot|
и в хост-системе.  Например, во многих дистрибутивах путь \verb|/etc/init.d| является символической
ссылкой, указывающей на каталог \verb|/etc/rc.d/init.d|.  Тогда, если в каком-либо скрипте загружается
файл \verb|/etc/init.d/functions|, то с учетом символической ссылки \verb|/etc/init.d|
должна быть сгенерирована файловая зависимость на \verb|/etc/rc.d/init.d/functions|.
Во многих других случаях, однако, содержимое каталога \verb|%buildroot| должно иметь приоритет над
содержимым корневой файловой системы.

Генерация зависимостей для команд рассмотрена в следующем разделе.

\section{Зависимости шелл-скриптов}
\label{shell-req}
Поднобнее остановимся на анализаторе зависимостей шелл-скриптов \verb|shell.req|, т.\,к. при
его реализации возникают вопросы, в разной степени характерные для многих других методов
поиска зависимостей.

Первичный анализ скрипта выполняется интерпретатором \verb|/bin/sh| с опцией \verb|--rpm-requires|,
т.\,е. задействуется специальный режим анализа кода, производный от режима проверки синтаксиса \verb|sh -n|.
Таким образом, дополнительным преимуществом \verb|shell.req| следует считать синтаксическую проверку
кода, выполняемую при поиске зависимостей.  Обнаружение синтаксических ошибок в скриптах можно отнести
к дополнительному тестированию, выполняемому при сборке (если \verb|shell.req| обнаруживает синтаксическую ошибку,
то сборка пакета завершается с ошибкой).  Проверка синтаксиса особенно важна для \%post-скриптов (см. раздел
\ref{post-script-deps}).

Особенностью шелл-скриптов является отсутствие специального механизма для указания требований (такого, как подключение
модулей в других языках программирования)~--- фактически, каждая \textit{команда} может порождать некоторую зависимость.
Вместе с отсутствием специального механизма исключений, который мог бы использоваться для условной загрузки кода,
это обостряет проблему порождения \textit{условных завсимостей}.  Например, для кода
\begin{verbatim}
if [ -f /etc/foo.conf ]; then
        . /etc/foo.conf
fi
if [ -f /usr/local/foo.conf ]; then
        . /usr/local/foo.conf
fi
\end{verbatim}
будут порождены файловые зависимости на \verb|/etc/foo.conf| и \verb|/usr/local/foo.conf|, при том,
что обе зависимости являются условными, а вторая~--- недопустимой (т.\,к. иерархия \verb|/usr/local|
не должна использоваться в пакетах).

Существует несколько способов, с помощью которых можно избежать порождения условных зависимостей:
\begin{itemize}
\item Можно переписать код таким образом, чтобы зависимось не порождалась.
Для этого можно <<спрятать>> команду или значение аргумента в переменную
\begin{verbatim}
foo=/usr/local/foo.conf
if [ -f $foo ]; then
        . $foo
fi
\end{verbatim}
либо дополнить команду специальным присваиванием, которое распознается анализатором
как инструкция игнорировать команду:
\begin{verbatim}
if [ -f /usr/local/foo.conf ]; then
        a= . /usr/local/foo.conf
fi
\end{verbatim}
Заметим, что в силу особенностей реализации интерпретатора зависимости в \textit{подстановках команд},
т.\,е. зависимости в конструкциях вида \verb|$(cmd ...)| также игнорируются.
\item Можно отфильтровать ненужные зависимости, используя специальные макросы в спекфайле
(см. раздел \ref{filter-deps}).
\item Для пакетов типа \verb|contrib| (содержащих скрипты, которые не предназначены для
непосредственного запуска пользователем), поиск шелл-зависимостей можно отключить:
\texttt{AutoReq: yes, noshell}.  Однако для пакетов, не относящихся к категории \verb|contrib|,
полностью отключать \verb|shell.req| не следует, т.\,к. желательно сохранить синтаксическую
проверку.  Вероятно, для такого класса пакетов нужно реализовать специальный режим
\texttt{AutoReq: yes, shell=syntax-check-only}.
\end{itemize}

Итак, синтаксический анализ позволяет обнаружить \textit{команды}, используемые в скрипте (аргументы некоторых стандартных команд,
как в примере с \verb|foo.conf|, также считаются командами).  Если команда имеет вид \textit{пути к файлу}, то для такой команды
\verb|find-package| порождает файловую зависимость; оставшиеся \textit{простые} команды подразделяются анализатором
на два вида: шелл-функции и исполняемые файлы.

Для простых команд выполняется \textit{элиминация зависимостей на функции}: формируется глобальный список шелл-функций,
которые определены в каком-либо файле в пределах пакета.  В дальнейшем команды с названием этих функций исключаются
из поиска зависимостей.  Дело в том, что интерпретатор не всегда может заранее определить, является ли вызываемая
команда функцией или исполняемым файлом.  Для реализации этой стадии требуется модифицировать режим \verb|--rpm-requires|
таким образом, чтобы в качестве зависимостей выводились не только вызываемые, но и все определяемые функции.

Оставшиеся команды считаются исполняемыми файлами, которые должны быть расположены в стандартных каталогах \verb|PATH|.
При формировании зависимостей для таких команд возникает следующее противоречее: с одной стороны, команды могут
перемещаться между каталогами (например, программу можно переместить из каталога \verb|/usr/bin| в каталог \verb|/bin|),
и тогда в качестве зависимости лучше использовать имя пакета.  В то же время, файлы могут перемещаться между
подпакетами (например, программы из базового подпакета могут быть перенесены в дополнительный подпакет), и тогда
зависимость на имя пакета не гарантирует налачия команды.  Можно было бы использовать отдельное пространство имен
для исполняемых команд~--- \verb|command(foo)|, однако при этом теряется различие между \verb|sbin|-командами,
доступными только пользователю \verb|root|, и \verb|bin|-командами, доступными всем пользователям.  Поэтому
сейчас реализован компромиссный вариант, в котором по умолчанию генерируется зависимость на имя пакета.

Однако команда не всегда может быть однозначно сопоставлена с именем пакета.  Если приоритетный путь \verb|/usr/bin/foo|
предоставляется двумя пакетами с разным именем (обычно такой путь является <<альтернативой>>, хотя возможны и конфликтующие
реализации), то нужно сгенерировать файловую зависимости на \verb|/usr/bin/foo|.  Если же два разных пути находятся
в одном пакете (например, \verb|/bin/foo| и \verb|/usr/bin/foo|~--- обычно один из путей в таком случае является символической
ссылкой), то лучше сгенерировать зависимость на имя пакета.  При этом \textit{приоритет путей} может быть разным: для скриптов,
расположенных в каталогах \verb|/sbin|, \verb|/usr/sbin| и в некоторых других системных каталогах поиск команд выполняется
в порядке
\verb|/sbin|, \verb|/bin|, \verb|/usr/sbin|, \verb|/usr/bin|,
а для остальных скриптов~---
\verb|/bin|, \verb|/sbin|, \verb|/usr/bin|, \verb|/usr/sbin|.
Как видно, различие между \verb|sbin|-скриптами и \verb|bin|-скриптами не является строгим~---
каталоги \verb|/sbin| и \verb|/usr/sbin| используются в обоих случаях.

Понятно, что результат поиска команды может зависеть не только от пакетов, установленных при сборке (в частности,
по установленным пакетам нельзя определить, для каких команд имеются конфликтующие реализации).  Поэтому при сборке
пакета сборочная система формирует \textit{глобальный индекс команд} для всех пакетов в репозитории, который
мы называем \verb|contents_index_bin|.  Алгоритм \verb|find-package|, как правило, использует этот индекс в приоритетном
порядке (чтобы сформировать достаточно общие зависимости для команд, имеющих альтернативные и конфликнующие реализации).

Однако существует несколько реальных команд, как в следующем примере, у которых отличается как путь, так и название
пакета.
\begin{verbatim}
/usr/bin/arpsend        arpsend
/usr/sbin/arpsend       vzctl
\end{verbatim}
В таких случаях с помощью \verb|contents_index_bin| уже нельзя сформировать зависимость достаточно общего вида~---
придется делать выбор в пользу одной из конкретных реализаций.  Поэтому в таких случаях приоритет при поиске снова
отдается установленным пакетам, т.\,к. нужная реализация, возможно, используется при сборке пакета.

Необходимо заметить, что использование глобального индекса нарушает принцип \textit{воспроизводимости} сборки:
результат сборки пактов должен зависеть только от исходного кода и от пакетов, используемых при сборке (т.\,е. от пакетов,
установленных в сборочный чрут для <<чистовой>> сборки).  При использовании глобального индекса команд получается,
что зависимости пакета могут в некоторой степени зависеть и от других пакетов в репозитории.  Поэтому, во-первых,
политика дистрибутива должна ограничивать размещение <<левых>> команд в стандартных каталогах \verb|PATH|.  Во-вторых,
если сборочная система строго конролирует инвариант перехода (см. введение) и, в частности, фиксирует любые изменения
зависимостей у пакетов после тестовой пересборки, то нужно реализовать дополнительных механизм контроля зависимостей,
которые могут измениться только из-за содержимого \verb|contents_index_bin|.

\pagebreak[4]

\section{Сборка perl-пакетов~--- rpm-build-perl}
Модульный подход, обозначенный в разделе \ref{modular-approach}, позволяет независимо разрабатывать
компоненты, дополняющие базовую политику сборки.  Одним из таких компонентов является пакет \verb|rpm-build-perl|.
В этот пакет вынесены скрипты поиска зависимостей и еще несколько файлов, относящихся к языку perl или направленных
на поддержку сборки perl-пакетов.  При этом в пакет \verb|rpm-build| добавлена зависимость на \verb|rpm-build-perl|~---
таким образом, поддержка perl-зависимостей сохранена для сборки всех пакетов.  Некоторые другие расширения,
однако, не могут быть внесены в базовую сборочную среду; для таких расширений должна быть прдумана специальная
схема поддержки зависимостей (см. \verb|rpm-build-mono| в разделе \ref{rpm-build-mono}).

Пакет \verb|rpm-build-perl| содержит следующие компоненты:
\begin{itemize}
\item Скрипт формирования Requires зависимостей \verb|perl.req| и соответствующий ему скрипт отбора файлов \verb|perl.req.files|.
\item Скрипт формирования Provides зависимостей \verb|perl.prov| и соответствующий ему скрипт отбора файлов \verb|perl.prov.files|.
\item Скрипт \verb|perl.clean| для очистики каталога \verb|%buildroot| на стадии brp.
\item Файл \verb|perl.def| с макросами, которые используются при сборке perl-пакетов.
\item Файл \verb|perl.env| для управления параметрами сборки (см. раздел \ref{perl-env-intro}).
\end{itemize}

По сравнению с традиционной реализацией было изменено представление зависимостей для модулей:
вместо \verb|perl(File::Spec)| используются зависимости вида \verb|perl(File/Spec.pm)|,
т.\,е. вместо имени модуля используется соответствующие компоненты имени файла.
Таким образом, выбрано унифицированное представление зависимостей для модулей и зависимостей
вида \verb|perl(getopts.pl)| и \verb|perl(sys/ioctl.ph)|.

Кратко остановимся на некоторых особенностях сборки perl-пакетов.  Базовая совместимость модулей
с интерпретатором выражается через зависимости на каталоги (см. раздел \ref{files-req}), при этом
не используется версионирование каталогов (механизм \verb|inc_version_list|
отключен при сборке интерпретатора).  Вообще, структура каталогов для модулей подвергнута максимальному упрощению.
Так, все модули из noarch пакетов располагаются в каталоге \verb|/usr/share/perl5|, так что результат
сборки таких пакетов, как правило, не зависит от версии интерпретатора.  Однако для компилируемых
модулей зависимости на каталог \verb|/usr/lib/perl5| или \verb|/usr/lib64/perl5| будет недостаточно.
Процедура сборки perl-расширений модифицирована таким образом, чтобы загружаемые объекты \verb|.so| компоновались
с библиотекой libperl.  А библиотека libperl в свою очередь наделяется именем (soname) вида \verb|libperl-5.14.so|.
Таким образом, бинарная совместимость модулей и интерпретатора конролируется стандартным способом~--- через
зависимости на soname библиотеки, при этом также используются set-версии (см. раздел \ref{set-versions}).
Всё это позволяет сформировать более \textit{точные} и менее \textit{жесткие} зависимости, которые позволяют
контролировать не только \textit{обратную}, но и \textit{прямую} совместимость (например,
бинарную совместимость модуля, собранного с новой версией интерпретатора, с более старой версией интерпретатора).

\subsection{Анализатор зависимостей perl.req}

Загрузка модулей в языке perl выполняется с помощью функции \verb|require| или
инструкции \verb|use| (которая сводится к вызову функции \verb|require|).
В традиционной реализации скрипт \verb|perl.req| с помощью регулярного
выражения ищет строки, которые начинаются со слов \verb|require| или \verb|use|,
и выполняет дальнейший разбор этих строк.

Рассмотрим фрагмент традиционной реализации \verb|perl.req|.
\begin{verbatim}
if (m/^(\s*)         # we hope the inclusion starts the line
    (require|use)\s+(?!\{)     # do not want 'do {' loops
    # quotes around name are always legal
    ['"]?([^; '"\t#]+)['"]?[\t; ]
    # the syntax for 'use' allows version requirements
    # the latter part is for "use base qw(Foo)" and friends special case
    \s*($modver_re|(qw\s*[(\/'"]\s*|['"])[^)\/"'\$]*?\s*[)\/"'])?
    /x)
) {
my ($whitespace, $statement, $module, $version) = ($1, $2, $3, $4);

# we only consider require statements that are flushed against
# the left edge. any other require statements give too many
# false positives, as they are usually inside of an if statement
# as a fallback module or a rarely used option
($whitespace ne "" && $statement eq "require") && next;

# skip if the phrase was "use of" -- shows up in gimp-perl, et al.
next if $module eq 'of';
\end{verbatim}
Как видно, регулярное выражение нельзя назвать простым.  Кроме того, регулярного выражения оказывается недостаточно.
Язык perl характеризуется очень сложным синтаксисом~--- неоднородной системой кавычек и ограничителей, многострочными
литералами here-documents, наконец, встроенной документацией POD.  Не случайно последняя проверка в приведенном фрагменте
<<отсеивает>> типичное вхождение слова use в предоложения английского языка (в дальнейшем выполняется еще несколько
похожих проверок).  Обращает на себя внимание и первая проверка: она оставляет только строки без отступа (а строки с отступом
считаются условными конструкциями).  Однако отступы в языке perl не являются значащами.  Кроме того, уровень вложенности
не всегда означает условную конструкцию, как в следующем типичном примере:
\begin{verbatim}
BEGIN {
  use Exporter;
  @EXPORT = qw(foo bar);
}
\end{verbatim}
Следует также отметить, что инструкции \verb|use| выполняются всегда (на стадии загрузки кода),
и поэтому понятие условных конструкций к ним не относится.

Таким образом, разбор кода на языке perl с помощью регулярных выражений нельзя считать надежным подходом.
Вообще, как говорят хакеры, <<Only perl can parse perl>>, т.\,е. надежный разбор кода на языке perl
может быть выполнен только средствами самого интерпретатора perl.

К счастью, интерпретатор предоставляет доступ к внутреннему представлению кода.  При загрузке кода
интерпретатор формирует дерево опкодов (которое обладает как признакми синтаксического дерева,
так и признаками байткода); в дальнейшем дерево <<выполняется>> с помощью отдельной процедуры (которую
можно считать прототипом виртуальной машины).  Модуль \verb|B|, иногда называемый <<компилятором>>,
предоставляет доступ к дереву опкодов, а также позволяет отключить основную стадию исполнения кода
(активизируя режим проверки синтаксиса \texttt{perl -c}).  Модуль \verb|O| иногда называют <<интерфейсом
компилятора>>~--- он упрощает загрузку дополнительных модулей, работающих в <<режиме компилятора>>.

Модуль \verb|B::Concise| позволяет отобразить дерево опкодов:
\begin{verbatim}
$ perl -MO=Concise -e 'require Foo; print 1'
9  <@> leave[1 ref] vKP/REFC ->(end)
1     <0> enter ->2
2     <;> nextstate(main 1 -e:1) v:{ ->3
4     <1> require sK/1 ->5
3        <$> const[PV "Foo.pm"] s/BARE ->4
5     <;> nextstate(main 1 -e:1) v:{ ->6
8     <@> print vK ->9
6        <0> pushmark s ->7
7        <$> const[IV 1] s ->8
-e syntax OK
\end{verbatim}

Дерево опкодов сохраняет всю важную информацию об исходном коде.
Модуль \verb|B::Deparse| позволяет реконструировать исходный код:
\begin{verbatim}
$ perl -MO=Deparse -e 'require Foo; print 1'
require Foo;
print 1;
-e syntax OK
\end{verbatim}

Идея <<нетрадиционной>> реализации \verb|perl.req| состоит в том, чтобы вместо регулярного выражения
использовать для извлечения зависимостей вспомогательный модуль \verb|B::PerlReq| (разработанный специально
для этой цели):
\begin{verbatim}
$ perl -MO=PerlReq -e 'require Foo; print 1'
perl(Foo.pm)
-e syntax OK
\end{verbatim}

Основным источником зависимостей в дереве опкодов являются опкоды \verb|require|, которые соответствуют
непосредственным вызовам функции \verb|require| и инструкциям \verb|use|.  Однако к образованию зависимостей
могут приводить и некоторые другие конструкции.  Например, версионирование зависимостей осуществляется
с помощью вызова статического метода \verb|VERSION|: инструкция вида
\begin{verbatim}
use Module 1.0 qw(list);
\end{verbatim}
на самом деле <<раскрывается>> в код
\begin{verbatim}
BEGIN {
    require Module;
    Module->VERSION(1.0);
    Module->import(list);
}
\end{verbatim}
Поэтому в модуле \verb|B::PerlReq| в качестве общего случая реализован анализ вызовов функций
и статических методов (в том числе выполняется реконструкция константных аргументов).  Это
позволяет обнаруживать отложенную загрузку модулей вида
\begin{verbatim}
use autouse Foo => qw(bar baz);
\end{verbatim}
за счет обработки вызова статического метода \verb|autouse->import|:
\begin{verbatim}
$ perl -MO=PerlReq -e 'use autouse Foo => qw(bar baz)'
perl(autouse.pm)
perl(Foo.pm)
-e syntax OK
\end{verbatim}

Анализ вызова функций и статических методов позволяет обнаружить довольно сложные способы образования
зависимостей.  Например, в следующих двух случаях
\begin{verbatim}
open $fh, ">", \$var;
IO::File->new(\$var, "w");
\end{verbatim}
при открытии файла вместо имени файла передается ссылка на переменную \verb|$var|.
В таких случаях доступ к файлу на диске заменяется доступом к содержимому переменной \verb|$var| (т.\,н. in-memory files).
Примитивы доступа к таким псевдофайлам реализованы в модуле \verb|PerlIO::scalar|, который загружается интерпретатором
по мере необходимости.  Соответствено, при обнаружении подобных конструкций модуль \verb|B::PerlReq| порождает зависимость
на \verb|perl(PerlIO/scalar.pm)|.

\subsection{Макросы и автоматизация сборки}
\label{perl-macros}

\section{Зависимости на ELF-библиотеки, set-версии}

\subsection{Пространство имен библиотек}

\subsection{Версионирование интерфейса, set-версии}
\label{set-versions}

\section{Другие методы поиска зависимостей}

\subsection{shebang.req}
\label{shebang-req}

\subsection{files.req}
\label{files-req}

\subsection{symlinks.req}
\label{symlinks-req}

\subsection{cpp.req}
\subsection{pkgconfig.req}
\subsection{pkgconfiglib.req}
\subsection{rpm-build-mono}
\label{rpm-build-mono}

\section{Зависимости \%post-скриптов}

\label{post-script-deps}

\section{Фильтрация зависимостей, weak provides}
\label{filter-deps}

\section{Подпакеты с отладочной информацией}

\label{debuginfo-subpackages}

\section{Проверки во время сборки пакетов}

\label{brp-verify}

\section{Разное}

\subsection{rpm4 vs rpm5}

\subsection{multiarch}

\subsection{компоненты rpm-build}

\subsection{Файлтриггеры}

\end{document}
