\documentclass[russian,a4paper,12pt,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{fullpage}
\usepackage{url}

\sloppy
\hyphenpenalty=666

\begin{document}
\title{Предложения по развитию\\системы управления пакетами RPM}
\author{Алексей Турбин \url{<at@altlinux.org>}}
\maketitle
\tableofcontents
\pagebreak[4]

\section*{Введение}
Ян Мёрдок (основатель проекта Debian) назвал управление пакетами <<самым
выдающимся достижением, которое Linux привнес в IT-отрасль>>.\footnote{\textit{The
single biggest advancement Linux has brought to the industry.}
\url{http://ianmurdock.com/solaris/how-package-management-changed-everything/}}
Мёрдок отмечает, в частности, возможность унифицированного обновления ПО по сети,
а также модель распределенной разработки, которая стала возможна благодаря разбиению
операционной системы на компоненты.

Нужно заметить, однако, что возможность обновления пакетов по сети
реализуется в виде надстройки (apt, yum) над базовым уровнем управления пакетами
(rpm, deb), тогда как модель распределенной разработки является не столько техническим,
сколько социальным аспектом разработки свободного ПО.  В то же время функции, реализуемые
на базовом уровне управления пакетами, подозрительно похожи на функции архиватора типа tar,
который существовал в UNIX всегда.
Действительно, rpm-пакеты можно рассматривать как <<тарболлы>>, а rpm~--- как
некоторое подобие tar (по крайней мере, в части установки пакетов).  Более того,
в некоторых системах <<тарболл>> и является основным форматом пакетов.  Возникает
вопрос: каковы главные особенности системы управления пакетами на базовом уровне,
делающие её принципиально отличной от архиватора?  Что можно считать
<<достижением>> на базовом уровне?

На первый взгляд, главным отличием rpm от архиватора является возможность обновления и удаления пакетов.
В отличие от обычного архиватора, rpm поддерживает базу пакетов \verb|rpmdb|, в которой хранится информация
об установленных пакетах и о файлах, ассоциированных с пакетами.  При обновлении пакетов эта информация
позволяет корректно выполнить замещение файлов и т.\,п.  Впрочем, нужно понимать, что некоторая сложность,
связанная с корректным замещением файлов, возникает вследствие использования традиционной иерархии файловой
системы, при которой файлы в зависимости от их назначения располагаются в разных системных каталогах.
Некоторые разработчики считают традиционную иерархию файловой системы слишком сложной.
Так, в дистрибутиве GoboLinux выполнена полная реорганизация файловой системы: каждому пакету отводится
собственный подкаталог в системном каталоге \verb|/Programs|.  Это радикально упрощает обновление пакетов,
сводя его к удалению старого каталога и распаковке нового архива.

На наш взгляд, принципальное отличие управления пакетами от <<управления тарболлами>> состоит в другом.
Архиватору безразлично содержимое файлов в архиве, распаковка~--- это его единственная функция; сохранность
байтов~--- это всё, что его в принципе интересует.  В то же время перед rpm стоит более сложная задача:
поддержка операционной системы в целостном, согласованном состоянии.  Фактически, базовый уровень
управления пакетами должен гарантировать работоспособность операционной системы (в той степени,
в которой это вообще возможно) и обеспечивать совместимость установленных компонентов ПО.  Возможность
обновления ПО по сети, отмеченную Мёрдоком, можно интерпретировать именно так~--- как поддержку ОС
в актуальном рабочем состоянии.

Таким образом, можно сказать, что базовый уровень управления пакетами является <<достижением>> настолько,
насколько он \textit{не сводится} к функциям архиватора.  В частности, в какой-то момент система управления
пакетами должна весьма сильно интересоваться содержимым файлов, входящих в пакет, т.\,к. работоспособность
операционной системы и совместимость компонентов ПО могут быть во многих случаях объяснены в терминах
содержимого тех или иных файлов.  Если же не интересоваться содержимым файлов, то гарантировать их согласованную
совместную работу, по-видимому, никак нельзя.

В rpm основным способом описания работоспособности и совместимости пакетов являются \textit{зависимости}.
При сборке пакетов rpm изучает содержимое файлов, входящих в пакет, и формирует зависимости пакета.
Зависимости Requires описывают требования, которые предъявляются к другим пакетам.  Зависимости Provides
в свою очередь описывают <<предоставляемые>> свойства пакета, которые могуть быть <<затребованы>> через
Requires в других пакетах.  Соответственно, в rpm имеются вспомогательные программы \verb|find-requires|
и \verb|find-provides|, которые выполняют поиск Requires и Provides зависимостей.  Эти две программы
составляют основу \textit{подсистемы автоматического поиска зависимостей} (эта подсистема также может быть
использована для автоматического поиска зависимостей типа \verb|Reqires(post)| в \%post-скриптах,
о чем подробнее в разделе \ref{post-script-deps}).  Большая часть данного документа посвящена
усовершенствованию этой подсистемы.  Как будет видно в дальнейшем, многие требования работоспособности
и совместимости пакетов могут быть описаны гораздо более точно (так, в разделе \ref{set-versions} описан
способ компактного представления множества символов, с помощью которого можно в значительной степени
решить проблему т.\,н. <<dll hell>>~--- проблему версионирования и неполной совместимости разделяемых библиотек).

Интересно отметить <<асимметричный>> характер системы управления пакетами на базовом уровне: содержимое
файлов изучается только во время сборки пакетов для формирования зависимостей.  На стадии же установки
rpm руководствуется зависимостями, полученными при сборке; а содержимое файлов его снова не интересует.
В терминах дихотомии Эрика Реймонда\footnote{\textit{Rule of Separation: Separate policy from mechanism;
separate interfaces from engines.} \url{http://www.faqs.org/docs/artu/ch01s06.html}}
можно сказать, что при установке пакетов работает базовый \textit{механизм}, тогда как \textit{политика}
управления пакетами на самом деле осуществляется во время сборки.

Политика сборки пакетов не обязательно должна ограничиваться анализом файлов для формирования зависимостей.
Можно реализовать более агрессивную политику сборки, направленную, во-первых, на автоматическую коррекцию содержимого
пакетов, а во-вторых, на процедуры автоматической верификации, которые должны быть выполнены, чтобы пакет успешно собрался.
Эти процедуры могут выполняться, в частности, на стадии brp (buildroot policy).  Примером коррекции содержимого
пакетов является процедура brp-debuginfo, которая используется для подготовки пакетов с отладочной информацией (см. раздел
\ref{debuginfo-subpackages}).  Некоторые процедуры автоматической верификции рассмотрены в разделе \ref{brp-verify}.

Однако не все проверки стоит выполнять при сборке пакета.  Некоторые проверки
являются специфическими для дистрибутива и поэтому не могут быть частью базовой
политики сборки пакета (например, сюда можно отнести формальное требование указывать
в \%changelog <<официальный>> e-mail адрес, связанный с проектом).  Другие проверки не требуют
доступа к содержимому файлов~--- например, проверка на соответствие FHS (filesystem hierarchy standard).
Другой пример: архитектурно-независимые пакеты (noarch) не должны содержать архитектурно-зависимых путей
(файлов в каталоге \verb|/usr/lib64| и подкаталогах).  Такие проверки можно оформить в виде отдельной программы
типа rpmlint.

Между прочим, последняя проверка является в некотором смысле недостаточной: не только в noarch пакетах не должно быть
архитектурно-зависимых путей, но и вообще при сборке на любой архитектуре должны получаться идентичные noarch пакеты.
Таким образом, выполнение такой проверки потребует синхронной сборки пакета на двух (или более) архитектурах, т.е.
она не может быть реализована на уровне rpm, а только на уровне сборочной системы (если сборочная система синхронизирует
сборку для нескольких архитектур).  В сборочной системе одного российского дистрибутива реализована именно такая~--- достаточно
строгая~--- политика верификации noarch пакетов.

Мы завершаем введение кратким обзором сборочной системы.\footnote{Подробнее см. \textit{Сборочная система git.alt}
в сборнике \url{http://www.altlinux.ru/media/book-thesis-Protva-2008-5.pdf}}  Приоритетной задачей сборочной системы
является автоматическое тестирование и верификация пакетов во время и после сборки, т.\,е. политика сборки, направленная
на поддержку целостности репозитория пакетов (в то время как, например, наличие веб-интерфейса для нас не представляет интереса).
Сборочная система характеризуется относительно высоким процентом отказов в приеме пакетов (при обнаружении дефектов в пакетах).
В то же время сборочная система работает полностью автоматически, и пакеты без дефектов поступают в репозиторий сразу же (проверка
вручную и дополнительное тестирование могут быть организованы перед синхронизацией репозитория на основной публичный сервер).

Политику сборочной системы можно описать в терминах \textit{формальной модели}: поступление новых пакетов моделируется
как переход репозитория из состояния $A_0$ в состояние $A_1$.  При этом, в идеале, в любом состоянии должно быть выполнено
формальное условие, которое можно назвать \textit{инвариантом перехода}: все пакеты должны успешно проходить тестовую пересборку,
и все пакеты должны успешно устанавливаться в базовую среду (basesystem).  В реальности контролировать инвариант перехода
удается лишь частично, т.\,к. тестовая пересборка всех пакетов требует довольно много вычислительных ресурсов.
Как следствие, нереализованной остается принципиально важный компонент сборочной системы~--- \textit{метарепозиторий},
который позволил бы учитывать взаимное влияние между пакетами и, в частности, контролировать изменение свойств пакета
после тестовой пересборки (а не только сам факт пересобираемости).

Интерфейс сборочной системы позволяет формировать \textit{задания} на сборку.  Задание может содержать несколько
пакетов, которые собираются в строгой последовательности (без изменения основного репозитория).  После этого моделируется
переход $A_0\to A_1$ и, если переход разрешен, задание \textit{транзакционно} применяется к репозиторию.  Таким образом,
сборочная система позволяет проводить несовместимые изменения~--- такие, как изменение soname библиотеки~--- при условии
синхронной пересборки (в этом же задании) всех несовместимых/зависимых пакетов.

К недостаткам сборочной системы можно отнести некоторые ограничения на возможность параллельной сборки,
т.\,к. параллельные переходы не моделируются.

\section{Раскрытие макросов в спекфайле}
\textit{Макросы} в rpm являются базовым механизмом параметризации.  С помощью
макросов можно задать как простейшие текстовые подстановки, так и более сложные
(в том числе рекурсивные) подстановки с аргументами.  В спекфайле <<вызов>> макроса
выполняется с помощью конструкций \verb|%{name}|, \verb|%{name args}| или (в сокращенной записи)
\verb|%name|, \verb|%name args|.

Однако использование макросов сопряжено с некоторой опасностью: когда rpm встречает неизвестный макрос
(т.\,е. одну из конструкций указанного вида, в которой макрос с именем \verb|name| не был заранее определён),
rpm оставляет макрос <<нераскрытым>> (т.\,е. сохраняет конструкцию в незименном виде, как если бы она не считалась
<<вызовом>> макроса).  При этом rpm не выполняет диагностики, с помощью которой можно было бы обнаружить
нераскрытые макросы.  Это порождает целый класс ошибок в пакетах.

Например, в пакете \verb|gnumeric-1.10.17-1-mdv2012.0.x86_64.rpm| содержится следующий \%preun-скрипт:
\begin{verbatim}
SCHEMAS=""
for SCHEMA in %schemas ; do
  SCHEMAS="$SCHEMAS /etc/gconf/schemas/$SCHEMA.schemas"
done
GCONF_CONFIG_SOURCE=`/usr/bin/gconftool-2 --get-default-source` \
/usr/bin/gconftool-2 --makefile-uninstall-rule $SCHEMAS >/dev/null || true
\end{verbatim}
Макрос \verb|%schemas| в этом скрипте остался нераскрытым.  Т.\,к. \%preun-скрипт
выполняется при удалении пакета, то при удалении будет выполнен вызов \verb|gconftool-2|
с неправильными аргументами, который должен завершиться с ошибкой (однако это ошибка игнорируется
с помощью конструкции \texttt{>/dev/null || true}).

Другой пример: в пакете \verb|stardict-3.0.1-10-mdv2011.0.x86_64.rpm| имеется \%preun-скрипт
\begin{verbatim}
%preun_install_gconf_schemas stardict
\end{verbatim}
При удалении такого пакета возникнет ошибка типа \texttt{fg: no job control} или \texttt{fg: no such job},
т.\,к. интерпретатор \verb|/bin/sh| считает такую синтаксическую конструкцию обращением к фоновому заданию.

Ещё один пример: пакет \verb|squid-3.1.16-1-mdv2012.0.x86_64.rpm| содержит \%postun-скрипт
\begin{verbatim}
/usr/share/rpm-helper/del-user squid $1 squid
%post cachemgr
%postun cachemgr
\end{verbatim}
Природа ошибки в данном случае более тонкая~--- эта ошибка не сводится к простому <<человеческому фактору>>,
к которому можно отнести опечатки в названиях макросов или <<забытые>> макросы.

Таким образом, чтобы обнаружить целый класс ошибок и повысить надёжность сборки пакетов, мы считаем принципильно
важным диагностировать (в том или ином виде) нераскрытые макросы во время сборки.  В дальнейшем также будет показано, что
определения многих макросов, специфичных для некоторой группы пакетов, могут быть вынесены в отдельный файл и находиться
в отдельном пакете (см. раздел \ref{def-macro-files}).  Это открывает ещё одну возможность для появления нераскрытых
макросов: нераскрытые макросы могут появиться из-за нарушения зависимостей или вследствие надостаточных \verb|BuildRequires|
зависимостей у пакетов.  Поэтому, прежде чем выносить макросы в отдельные файлы, необходимо реализовать защиту от ошибок,
к которым это может привести.

Некоторая сложность в реализации проверки на нераскрытые макросы связана с тем, что rpm не делает специального различия
между <<ключевыми словами>> и сокращенной записью макросов (например, rpm позволяет определить макрос \verb|%build|,
в результате чего будет нарушена структура спекфайла~-- исчезнет секция \verb|%build|).  Кроме того, некоторые <<ключевые слова>>
являются специфичными для отдельных секций спекфайла (например, атрибут \verb|%ghost| используется только в секции \verb|%files|).
Поэтому в текущей реализации проверка выполняется немного по-разному в зависимости от секции спекфайла (проверка реализована
на уровне функции \verb|parseSpec|).

Как уже было сказано, если определения макросов, используемых в спекфайле, содержатся в отдельном пакете,
то в спекфайл должна быть добавлена зависимость \verb|BuildRequires| на этот пакет.  Однако, чтобы извлечь эту зависимость,
нужно распарсить спекфайл, который содержит нераскрытые макросы.  Поэтому желательно реализовать два режима
проверки: строгий и мягкий.  В \textit{строгом} режиме работа rpm завершается с ошибкой, если нераскрытые макросы обнаружены
по крайней мере в некоторых секциях спекфайла (таких как \%post-скрипты).  Строгий режим используется по умолчанию при сборке пакета.
В \textit{мягком} режиме ошибки заменяются на предупреждения, что позволяет распарсить спекфал и извлечь зависимости.

\section{Оптимизация зависимостей}

\section{Модульная система поиска зависимостей}

\label{def-macro-files}

\section{Файловые зависимости и процедура find-package}

\section{Зависимости шелл-скриптов}

\section{Сборка perl-пакетов~--- rpm-build-perl}

\section{Зависимости на ELF-библиотеки, set-версии}

\label{set-versions}

\section{Другие методы поиска зависимостей}

\subsection{shebang.req}
\subsection{files.req}
\subsection{symlinks.req}
\subsection{cpp.req}
\subsection{pkgconfig.req}
\subsection{pkgconfiglib.req}

\section{Зависимости \%post-скриптов}

\label{post-script-deps}

\section{Фильтрация зависимостей, weak provides}

\section{Подпакеты с отладочной информацией}

\label{debuginfo-subpackages}

\section{Проверки во время сборки пакетов}

\label{brp-verify}

\section{Разное}

\subsection{rpm4 vs rpm5}

\subsection{multiarch}

\subsection{компоненты rpm-build}

\subsection{Файлтриггеры}

\end{document}
