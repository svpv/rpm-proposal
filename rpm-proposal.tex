\documentclass[russian,a4paper,12pt,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{fullpage}
\usepackage{url}

\sloppy
\hyphenpenalty=666

\begin{document}
\title{Предложения по развитию\\системы управления пакетами RPM}
\author{Алексей Турбин \url{<at@altlinux.org>}}
\maketitle
\tableofcontents
\pagebreak[4]

\section*{Введение}
Ян Мёрдок (основатель проекта Debian) назвал управление пакетами <<самым
выдающимся достижением, которое Linux привнес в IT-отрасль>>.\footnote{\textit{The
single biggest advancement Linux has brought to the industry.}
\url{http://ianmurdock.com/solaris/how-package-management-changed-everything/}}
Мёрдок отмечает, в частности, возможность унифицированного обновления ПО по сети,
а также модель распределенной разработки, которая стала возможна благодаря разбиению
операционной системы на компоненты.

Нужно заметить, однако, что возможность обновления пакетов по сети
реализуется в виде надстройки (apt, yum) над базовым уровнем управления пакетами
(rpm, deb), тогда как модель распределенной разработки является не столько техническим,
сколько социальным аспектом разработки свободного ПО.  В то же время функции, реализуемые
на базовом уровне управления пакетами, подозрительно похожи на функции архиватора типа tar,
который существовал в UNIX всегда.
Действительно, rpm-пакеты можно рассматривать как <<тарболлы>>, а rpm~--- как
некоторое подобие tar (по крайней мере, в части установки пакетов).  Более того,
в некоторых системах <<тарболл>> и является основным форматом пакетов.  Возникает
вопрос: каковы главные особенности системы управления пакетами на базовом уровне,
делающие ее принципиально отличной от архиватора?  Что можно считать
<<достижением>> на базовом уровне?

На первый взгляд, главным отличием rpm от архиватора является возможность обновления и удаления пакетов.
В отличие от обычного архиватора, rpm поддерживает базу пакетов \verb|rpmdb|, в которой хранится информация
об установленных пакетах и о файлах, ассоциированных с пакетами.  При обновлении пакетов эта информация
позволяет корректно выполнить замещение файлов и т.\,п.  Впрочем, нужно понимать, что некоторая сложность,
связанная с корректным замещением файлов, возникает вследствие использования традиционной иерархии файловой
системы, при которой файлы в зависимости от их назначения располагаются в разных системных каталогах.
Некоторые разработчики считают традиционную иерархию файловой системы слишком сложной.
Так, в дистрибутиве GoboLinux выполнена полная реорганизация файловой системы: каждому пакету отводится
собственный подкаталог в системном каталоге \verb|/Programs|.  Это радикально упрощает обновление пакетов,
сводя его к удалению старого каталога и распаковке нового архива.

На наш взгляд, принципальное отличие управления пакетами от <<управления тарболлами>> состоит в другом.
Архиватору безразлично содержимое файлов в архиве, распаковка~--- это его единственная функция; сохранность
байтов~--- это всё, что его в принципе интересует.  В то же время перед rpm стоит более сложная задача:
поддержка операционной системы в целостном, согласованном состоянии.  Фактически, базовый уровень
управления пакетами должен гарантировать работоспособность операционной системы (в той степени,
в которой это вообще возможно) и обеспечивать совместимость установленных компонентов ПО.  Возможность
обновления ПО по сети, отмеченную Мёрдоком, можно интерпретировать именно так~--- как поддержку ОС
в актуальном рабочем состоянии.

Таким образом, можно сказать, что базовый уровень управления пакетами является <<достижением>> настолько,
насколько он \textit{не сводится} к функциям архиватора.  В частности, в какой-то момент система управления
пакетами должна весьма сильно интересоваться содержимым файлов, входящих в пакет, т.\,к. работоспособность
операционной системы и совместимость компонентов ПО могут быть во многих случаях объяснены в терминах
содержимого тех или иных файлов.  Если же не интересоваться содержимым файлов, то гарантировать их согласованную
совместную работу, по-видимому, никак нельзя.

В rpm основным способом описания работоспособности и совместимости пакетов являются \textit{зависимости}.
При сборке пакетов rpm изучает содержимое файлов, входящих в пакет, и формирует зависимости пакета.
Зависимости Requires описывают требования, которые предъявляются к другим пакетам.  Зависимости Provides
в свою очередь описывают <<предоставляемые>> свойства пакета, которые могуть быть <<затребованы>> через
Requires в других пакетах.  Соответственно, в rpm имеются вспомогательные программы \verb|find-requires|
и \verb|find-provides|, которые выполняют поиск Requires и Provides зависимостей.  Эти две программы
составляют основу \textit{подсистемы автоматического поиска зависимостей} (эта подсистема также может быть
использована для автоматического поиска зависимостей типа \verb|Reqires(post)| в \%post-скриптах,
о чем подробнее в разделе \ref{post-script-deps}).  Большая часть данного документа посвящена
усовершенствованию этой подсистемы.  Как будет видно в дальнейшем, многие требования работоспособности
и совместимости пакетов могут быть описаны гораздо более точно (так, в разделе \ref{set-versions} описан
способ компактного представления множества символов, с помощью которого можно в значительной степени
решить проблему т.\,н. <<dll hell>>~--- проблему версионирования и неполной совместимости разделяемых библиотек).

Интересно отметить <<асимметричный>> характер системы управления пакетами на базовом уровне: содержимое
файлов изучается только во время сборки пакетов для формирования зависимостей.  На стадии же установки
rpm руководствуется зависимостями, полученными при сборке; а содержимое файлов его снова не интересует.
В терминах дихотомии Эрика Реймонда\footnote{\textit{Rule of Separation: Separate policy from mechanism;
separate interfaces from engines.} \url{http://www.faqs.org/docs/artu/ch01s06.html}}
можно сказать, что при установке пакетов работает базовый \textit{механизм}, тогда как \textit{политика}
управления пакетами на самом деле осуществляется во время сборки.

Политика сборки пакетов не обязательно должна ограничиваться анализом файлов для формирования зависимостей.
Можно реализовать более агрессивную политику сборки, направленную, во-первых, на автоматическую коррекцию содержимого
пакетов, а во-вторых, на автоматическую верификцию, которая должна быть выполнена, чтобы пакет успешно собрался.
Процедуры верификации могут выполняться, в частности, на стадии brp (buildroot policy).  Примером коррекции содержимого
пакетов является процедура brp-debuginfo, которая используется для подготовки пакетов с отладочной информацией (см. раздел
\ref{debuginfo-subpackages}).  Некоторые процедуры автоматической верификции рассмотрены в разделе \ref{brp-verify}.

Однако не все проверки стоит выполнять при сборке пакета.  Некоторые проверки
являются специфическими для дистрибутива и поэтому не могут быть частью базовой
политики сборки пакета (например, сюда можно отнести формальное требование указывать
в \%changelog <<официальный>> e-mail адрес, связанный с проектом).  Другие проверки не требуют
доступа к содержимому файлов~--- например, проверка путей на соответствие FHS (filesystem hierarchy standard).
Другой пример: архитектурно-независимые пакеты (noarch) не должны содержать архитектурно-зависимых путей
(файлов в каталоге \verb|/usr/lib64| и подкаталогах).  Такие проверки можно оформить в виде отдельной программы
типа rpmlint.

Между прочим, последняя проверка является во многих отношениях недостаточной: в noarch пакетах не только не должно быть
архитектурно-зависимых путей, но и вообще при сборке на любой архитектуре должны получаться \emph{идентичные} noarch пакеты.
Таким образом, выполнение такой проверки потребует синхронной сборки пакета на двух (или более) архитектурах, т.е.
она не может быть реализована на уровне rpm, а только на уровне сборочной системы (если сборочная система синхронизирует
сборку для нескольких архитектур).  В сборочной системе одного российского дистрибутива реализована именно такая~--- достаточно
строгая~--- политика верификации noarch пакетов.

Мы завершаем введение кратким обзором сборочной системы.\footnote{Подробнее см. \textit{Сборочная система git.alt}
в сборнике \url{http://www.altlinux.ru/media/book-thesis-Protva-2008-5.pdf}}  Приоритетной задачей сборочной системы
является автоматическое тестирование и верификация пакетов во время и после сборки, т.\,е. политика сборки, направленная
на поддержку целостности репозитория пакетов (в то время как, например, наличие веб-интерфейса для нас не представляет интереса).
Сборочная система характеризуется относительно высоким процентом отказов в приеме пакетов (при обнаружении дефектов в пакетах).
В то же время сборочная система работает полностью автоматически, и пакеты без дефектов поступают в репозиторий сразу же (проверка
вручную и дополнительное тестирование могут быть организованы перед публикацией репозитория на официальном сервере).

Политику сборочной системы можно описать в терминах \textit{формальной модели}: поступление новых пакетов моделируется
как переход репозитория из состояния $A_0$ в состояние $A_1$.  При этом, в идеале, в любом состоянии должно быть выполнено
формальное условие, которое можно назвать \textit{инвариантом перехода}: все пакеты должны успешно проходить тестовую пересборку,
и все пакеты должны успешно устанавливаться в базовую среду (basesystem).  В реальности контролировать инвариант перехода
удается лишь частично, т.\,к. тестовая пересборка всех пакетов требует довольно много вычислительных ресурсов.
Как следствие, нереализованной остается принципиально важный компонент сборочной системы~--- \textit{метарепозиторий},
который позволил бы учитывать взаимное влияние между пакетами и, в частности, контролировать изменение свойств пакета
после тестовой пересборки (а не только сам факт пересобираемости).

Интерфейс сборочной системы позволяет формировать \textit{задания} на сборку.  Задание может содержать несколько
пакетов, которые собираются в строгой последовательности (без изменения основного репозитория).  После этого моделируется
переход $A_0\to A_1$ и, если переход разрешен, задание \textit{транзакционно} применяется к репозиторию.  Таким образом,
сборочная система позволяет проводить несовместимые изменения~--- такие, как изменение soname библиотеки~--- при условии
синхронной пересборки (в этом же задании) всех несовместимых/зависимых пакетов.

К недостаткам сборочной системы можно отнести некоторые ограничения на возможность параллельной сборки,
т.\,к. параллельные переходы не моделируются.

\section{Раскрытие макросов в спекфайле}
\textit{Макросы} в rpm являются базовым механизмом параметризации.  С помощью
макросов можно задать как простейшие текстовые подстановки, так и более сложные
(в том числе рекурсивные) подстановки с аргументами.  В спекфайле <<вызов>> макроса
выполняется с помощью конструкций \verb|%{name}|, \verb|%{name args}| или (в сокращенной записи)
\verb|%name|, \verb|%name args|.

Однако использование макросов сопряжено с некоторой опасностью: когда rpm встречает неизвестный макрос
(т.\,е. одну из конструкций указанного вида, в которой макрос с именем \verb|name| не был заранее определен),
rpm оставляет макрос <<нераскрытым>> (т.\,е. сохраняет конструкцию в незименном виде, как если бы она не считалась
<<вызовом>> макроса).  При этом rpm не выводит предупреждений, с помощью которых можно было бы обнаружить
нераскрытые макросы.  Это порождает целый класс ошибок в пакетах.

Например, в пакете \verb|gnumeric-1.10.17-1-mdv2012.0.x86_64.rpm| содержится следующий \%preun-скрипт:
\begin{verbatim}
SCHEMAS=""
for SCHEMA in %schemas ; do
  SCHEMAS="$SCHEMAS /etc/gconf/schemas/$SCHEMA.schemas"
done
GCONF_CONFIG_SOURCE=`/usr/bin/gconftool-2 --get-default-source` \
/usr/bin/gconftool-2 --makefile-uninstall-rule $SCHEMAS >/dev/null || true
\end{verbatim}
Макрос \verb|%schemas| в этом скрипте остался нераскрытым.  Т.\,к. \%preun-скрипт
выполняется при удалении пакета, то при удалении будет выполнен вызов \verb|gconftool-2|
с неправильными аргументами, который должен завершиться с ошибкой (однако эта ошибка игнорируется
с помощью конструкции \texttt{>/dev/null || true}).

Другой пример: в пакете \verb|stardict-3.0.1-10-mdv2011.0.x86_64.rpm| имеется \%preun-скрипт
\begin{verbatim}
%preun_install_gconf_schemas stardict
\end{verbatim}
При удалении такого пакета возникнет ошибка типа \texttt{fg: no job control} или \texttt{fg: no such job},
т.\,к. интерпретатор \verb|/bin/sh| считает такую синтаксическую конструкцию обращением к фоновому заданию.

Ещё один пример: пакет \verb|squid-3.1.16-1-mdv2012.0.x86_64.rpm| содержит \%postun-скрипт
\begin{verbatim}
/usr/share/rpm-helper/del-user squid $1 squid
%post cachemgr
%postun cachemgr
\end{verbatim}
Природа ошибки в данном случае более тонкая~--- эта ошибка не сводится к простому <<человеческому фактору>>,
к которому можно отнести опечатки в названиях макросов или <<забытые>> макросы.

Таким образом, чтобы обнаружить целый класс ошибок и повысить надежность сборки пакетов, мы считаем принципильно
важным диагностировать (в том или ином виде) нераскрытые макросы во время сборки.  В дальнейшем также будет показано, что
определения многих макросов, специфичных для некоторой группы пакетов, могут быть вынесены в отдельный файл и находиться
в отдельном пакете (см. раздел \ref{def-macro-files}).  Это открывает еще одну возможность для появления нераскрытых
макросов: нераскрытые макросы могут появиться из-за нарушения зависимостей или вследствие недостаточных \verb|BuildRequires|
зависимостей у пакетов.  Поэтому, прежде чем выносить определения макросов в отдельные файлы, необходимо реализовать защиту от ошибок,
к которым это может привести.

Некоторая сложность в реализации проверки на нераскрытые макросы связана с тем, что rpm не делает специального различия
между <<ключевыми словами>> и сокращенной записью макросов (например, rpm позволяет определить макрос с именем \verb|build|,
в результате чего будет нарушена структура спекфайла~--- исчезнет секция \verb|%build|).  Кроме того, некоторые <<ключевые слова>>
являются специфичными для отдельных секций спекфайла (например, атрибут \verb|%ghost| используется только в секции \verb|%files|).
Поэтому в текущей реализации проверка выполняется немного по-разному в зависимости от секции спекфайла (проверка реализована
на уровне функции \verb|parseSpec|).

Как уже было сказано, если определения макросов, используемых в спекфайле, содержатся в отдельном пакете,
то в спекфайл должна быть добавлена зависимость \verb|BuildRequires| на этот пакет.  Однако, чтобы извлечь эту зависимость,
нужно распарсить спекфайл, который содержит нераскрытые макросы.  Поэтому желательно реализовать два режима
проверки: строгий и мягкий.  В \textit{строгом} режиме работа rpm завершается с ошибкой, если нераскрытые макросы обнаружены
по крайней мере в некоторых секциях спекфайла (таких как \%post-скрипты).  Строгий режим используется по умолчанию при сборке пакета.
В \textit{мягком} режиме ошибки заменяются на предупреждения, что позволяет распарсить спекфал и извлечь зависимости.

\section{Оптимизация зависимостей}
\label{deps-optimization}
Большая часть предложений в данном документе направлена на совершенствование зависимостей у пакетов;
в том числе предполагается реализация новых типов зависимостей.  Зависимостей станет много.  Это не только
увеличивает размер пакетов, но и повышает нагрузку на сборочную систему, увеличивает время, необходимое
для проверки зависимостей при установке пакетов и т.\,п.  Поэтому, прежде чем добавлять новые~--- полезные~---
зависимости, следует рассмотреть способы оптимизации лишних зависимостей~--- зависимостей, которые можно
считать бесполезным.

Прежде всего, можно реализовать \textit{слияние} <<похожих>> зависимостей внутри отдельно взятого подпакета.
Например, зависимость с версией \verb|Provides: foo = 1.0| делает ненужной зависимость без версии \verb|Provides: foo|,
а из двух зависимостей с версиями \verb|Requires: bar >= 1.0| и \verb|Requires: bar >= 2.0| можно оставить только
одну~--- в данном случае с наибольшей версией.  В общем виде, с учетом всевозможных атрибутов зависимостей,
алгоритм слияния может быть довольно сложным.

Однако главным источником лишних зависимостей являются автоматически сгенерированные зависимости \verb|Requires|,
которые могут быть разрешены внутри своего подпакета в соответствующие зависимости \verb|Provides|.  Это
связано с тем, что скрипты геренации зависимостей \verb|Requires| обычно не учитывают то, что некоторые
из этих зависимостей предоставляются тем же самым пакетом (и поэтому всегда будут удовлетворены).
Вместо того, чтобы модифицировать скрипты генерации зависимостей, лучше реализовать глобальную оптимизацю:
исключать из пакета зависимости Requires, которые удовлетворяются зависимостями Provides в этом же пакете.
Эта оптимизация, однако, не может быть распространена на зависимости c некоторыми флагами типа \verb|Requires(pre)|~---
опять же, корректная реализация должна учитывать всевозможные специальные случаи.

В качестве примера рассмотрим зависимости пакета\\ \verb|perl-XML-SAX-0.960.0-2-mdv2011.0.noarch.rpm|.
\begin{verbatim}
Requires: perl(XML::SAX::PurePerl::DTDDecls)
Requires: perl(XML::SAX::PurePerl::DocType)
Requires: perl(XML::SAX::PurePerl::EncodingDetect)
Requires: perl(XML::SAX::PurePerl::Productions)
...
Provides: perl(XML::SAX::PurePerl::DTDDecls)
Provides: perl(XML::SAX::PurePerl::DebugHandler)
Provides: perl(XML::SAX::PurePerl::DocType)
Provides: perl(XML::SAX::PurePerl::EncodingDetect)
Provides: perl(XML::SAX::PurePerl::Exception)
Provides: perl(XML::SAX::PurePerl::Productions)
...
\end{verbatim}
Большую часть \verb|Requires| зависимостей в этом пакете следует отнести к лишним зависимостям~---
а именно, почти все зависимости вида \verb|perl(XML::SAX::...)|.

Оптимизация зависимостей может не ограничиваться зависимостями в пределах одного подпакета:
оптимизацию можно распространить на подпакеты, собираемые из одного исходного пакета, в том случае,
если подпакеты связаны строгой зависимостью.  \textit{Строгой зависимостью} мы называем зависимость
вида \verb|Requires: %name = %version-%release|, которая требует базовый подпакет с указанием не
только версии, но и релиза (номера сборки).  Тогда, если сборочная система не принимает пакеты
без последовательного увеличения либо версии, либо релиза, то можно считать, что строгая зависимость
уникально идентифицирует базовый подпакет.

Идея оптимизации состоит в том, что наличие строгой зависимости позволяет
оптимизировать некоторые другие~--- нестрогие~--- зависимости.  В качестве пример
рассмотрим зависимости пакета \verb|bzip2-1.0.6-3-mdv2011.0.x86_64.rpm|.
\begin{verbatim}
Requires: lib64bzip2_1 = 1.0.6-3
Requires: libbz2.so.1()(64bit)
Requires: libc.so.6()(64bit)
\end{verbatim}
Здесь первая зависимость является строгой~--- она уникально идентифицирует базовый подпакет с библиотекой сжатия.
В таком случае можно упразднить вторую зависимость~--- на soname библиотеки (эта зависимость предоставляется
базовым подпакетом, на который уже имеется строгая зависимость).

Вообще, если пакет \verb|%name-foo| содержит строгую зависимось на некоторый подпакет \verb|%name-base|,
то это позволяет удалить из пакета \verb|%name-foo| два рода \verb|Requires| зависимостей:
\begin{itemize}
\item Зависимости, которые \textit{представляются} пакетом \verb|%name-base|; или же, несколько точнее,
зависимости, которые могут быть удовлетворены \verb|Provides| зависимостями пакета \verb|%name-base|.
\item Зависимосте, которые \textit{уже требуются} пакетом \verb|%name-base|; или же, несколько точнее,
зависимости, которые могут быть подчинены \verb|Requires| зависимостям пакета \verb|%name-base|
в смысле возможности слияния.
\end{itemize}
В примере с \verb|bzip2| зависимость \verb|Requires: libc.so.6()(64bit)| относится к зависимостям второго рода
(базовый подпакет \verb|lib64bzip2_1| содержит такую же зависимость).

Некоторая сложность при оптимизации зависимостей второго рода связана с возможностью строгих \textit{циклических}
зависимостей.  \textit{Наивная} оптимизация зависимостей второго рода может привести к полному~--- <<циклическому>>~---
удалению зависимостей у подпакетов, которые образуют цикл.

Строгие зависимости между подпакетами можно наделить \textit{транзитивностью}: если подпакет \verb|foo| содержит
строгую зависимость на подпакет \verb|bar|, а подпакет \verb|bar| содержит строгую зависимость на подпакет \verb|baz|,
то можно считать, что подпакет \verb|foo| содержит строгую зависимость на пакет \verb|baz| (и оптимизировать зависимости
пакета \verb|foo| не только относительно пакета \verb|bar|, но и \verb|baz|).

Может возникнуть вопрос: в какой степени строгие зависимости действительно являются строгими?
Не стоит ли реализовать еще более строгие зависимости типа \verb|build-id|, которые идентифицируют пакет по его содержимому?
Можно указать два сценария, при которых строгие зависимости оказываются недостаточно строгими:
\begin{itemize}
\item Какой-либо посторониий пакет пердоставляет зависимость вида \verb|Provides: %name = %version-%release| и,
таким образом, удовлетворяет строгую зависимость Requires.
\item Сборка пакета выполняется без увеличения релиза (возможно, для другого дистрибутива), и возникает два набора пакетов.
Строгие зависимости не предотвращают <<перемешивания>> пакетов из обоих наборов.
\end{itemize}
В обоих случаях оптимизация зависимостей может оказаться некорректной, т.\,к. оптимизация выполняется в предположении,
что строгая зависимость уникально идентифицирует базовый пакет и его зависимости (а оказывается, что базовый пакет можно <<подменить>>).

На наш взгляд, возможность подмены базового пакета является скорее гипотетической, и на практике строгие зависимости
можно считать достаточно строгими.  Существует, однако, один дефект в реализации rpm, который может сделать строгие
зависимости менее строгими: сравнение версий у зависимостей выполняется таким образом, что зависимость вида
\verb|Provides: foo = %version| (с версией, но без релиза) удовлетворяет любую зависимость вида
\verb|Requires: foo = %version-%release| (с такой же версией и с релизом).
По-видимому, алгоритм сопоставления зависимостей в rpm должен быть скорректирован.

\section{Модульная система поиска зависимостей}
На последних стадиях сборки пакета выполняется автоматический поиск зависимостей:
rpm запускает скрипты \verb|find-requires| и \verb|find-provides|, которые анализируют
содержимое файлов в пакете и формируют соответственно \verb|Requires| и \verb|Provides| зависимости.

Почти во всех дистрибутивах скрипты \verb|find-requires| и \verb|find-provides| являются
монолитными программами, т.\,е. добавление новых типов зависимостей требует непосредственной модификации
этих скриптов.  Задача \textit{модульной системы поиска зависимостей}\footnote{См. также
\textit{Автоматический поиск зависимостей в rpm-пакетах} в сборнике
\url{http://www.altlinux.ru/media/protva4.pdf}}
состоит в том, чтобы для каждого типа зависимостей выделить соотвествующие программы поиска зависимостей
и сделать возможным независимое добавление зависимостей новых типов.  В скриптах \verb|find-requires| и \verb|find-provides|
должен остаться только вспомогательный код диспетчеризации.

Рассмотрим фрагмент монолитного скрипта \verb|find-requires|:
\begin{verbatim}
# --- Grab the file manifest and classify files.
exelist=`echo $filelist | xargs -r file | \
        grep -Ev ":.* (commands|script)[, ]" | \
        grep ":.*executable" | cut -d: -f1`
scriptlist=`echo $filelist | xargs -r file | \
        grep -E ":.* (commands|script)[, ]" | cut -d: -f1`

# --- Executable dependency sonames.
  for f in $exelist; do
    [ -r $f -a -x $f ] || continue
    lib64=`if file -L $f 2>/dev/null | \
        grep "ELF 64-bit" >/dev/null; then echo "$mark64"; fi`
    ldd $f | awk '/=>/ {
        if ($1 !~ /libNoVersion.so/ && $1 !~ /4[um]lib.so/) {
            gsub(/'\''"/,"\\&",$1);
            printf "%s'$lib64'\n", $1
        }
    }'
  done | xargs -r -n 1 basename | sort -u
\end{verbatim}
Данную схему поиска зависимостей можно описать так: сначала rpm классифицирует
все имеющиеся файлы и формирует разные категории файлов~--- \textit{отбирает} файлы
для поиска зависимостей, причем основным инструменом классификации является утилита \verb|file(1)|.
Затем для каждой группы выполняется анализ файлов и формируются соответствующие зависимости (в
приведенном фрагменте отбираются исполняемые программы и с помощью \verb|ldd(1)| определяются
разделяемые библиотеки, необходимые для запуска этих программ).

Скрипт \verb|find-requires| можно сделать модульным, если для каждого типа зависимостей выделить
две программы: программу \textit{отбора} файлов и программу \textit{анализа} файлов.  Тогда после реорганизации
работу скрипта \verb|find-requires| можно пояснить следующим образом:
\begin{itemize}
\item Утилита \verb|file(1)| запускается только один раз~--- в скрипте \verb|find-requires|.  Таким образом,
скрипт \verb|find-requires| формирует список файлов и их <<типов>>.  Дальнейшая работа \verb|find-requires|
сводится к вызову программ поиска зависимостей.  Для определенности будем рассматривать зависимости на разделяемые библиотеки.
\item Первая программа~--- с именем \verb|lib.req.files|~--- по списку файлов и их <<типов>> отбирает файлы,
которые содержат зависимости на разделяемые библиотеки.  Список отобранных файлов возвращается в \verb|find-requires|.
\item Затем \verb|find-requires| запускает вторую программу~--- с именем \verb|lib.req|~--- которая выполняет
анализ отобранных файлов и формирует список зависимостей на разделяемые библиотеки.
\end{itemize}

\textit{Модульность}\label{modular-approach} данной схемы состоит в том,
что \verb|find-requires| запускаются все имеющиеся программы поиска зависимостей
(по шаблону \verb|*.req.files| и \verb|*.req|) из каталога \verb|/usr/lib/rpm|.  Скрипт \verb|find-provides| работает аналогична
(запускаются программы с суффиксом \verb|.prov| вместо \verb|.req|).  Таким образом, для добавления нового типа зависимостей
нужно написать четыре программы: программу отбора файлов и программу анализа файлов, соответственно для Requires и Provides.

Другим аспектом модульности является возможность, в дополнение к новому типу зависимостей, реализовать макросы,
предназначенные для некоторой группы пакетов.  Как правило, такие макросы используются для того, чтобы упростить
сборку и унифицировать некоторые конструкции в спекфайлах (см. макросы для perl-пакетов в разделе \ref{perl-macros}).
Макросы также могут использоваться для того, чтобы управлять некоторыми параметрами сборки.

Макросы могут располагаться в отдельных файлах и подключаться по такому же модульному принципу.
Рассмотрим два вида файлов с макросами~--- файлы с суффиксом \verb|.def| и файлы с суффиксом \verb|.env|.
Файлы с суффиксом \verb|.def|\label{def-macro-files} являются традиционными файлами определения макросов.  Например,
в файле \verb|perl.def| определен следующий макрос, который позволяет в <<императивном стиле>> задать дополнительные
каталоги для perl-модулей:
\begin{verbatim}
%add_perl_lib_path()  %global _perl_lib_path %{?_perl_lib_path} %*
\end{verbatim}

У файлов с суффиксом \verb|.def| другое назначение~--- они позволяют <<вклиниваться>> в некоторые стадии сборки пакетов
с достаточно произвольным кодом, который генерируется с учетом текущего макроконтекста в спекфайле.
Например, в файле \verb|perl.env|\label{perl-env-intro} имеется следующая строка:
\begin{verbatim}
%{?_perl_lib_path:export RPM_PERL_LIB_PATH="%_perl_lib_path"}
\end{verbatim}
Таким образом, если в спекфайле был задан макрос \verb|_perl_lib_path|, то его значение экспортируется
в виде перменной окружения \verb|RPM_PERL_LIB_PATH|.  В дальнейшем значение этой переменной учитыватеся
в скриптах поиска зависимостей \verb|perl.req| и \verb|perl.prov|.

\section{Файловые зависимости и процедура find-package}
\label{file-deps}\textit{Файловыми зависимостями} мы называем зависимости вида \verb|Requires: /usr/foo|,
в~которых в качестве имени зависимости используется путь к файлу (или каталогу).  В rpm реализована
полная поддержка файловых зависимостей.  А именно, файловая зависимость может быть удовлетворена двумя способами:
\begin{itemize}
\item Если пакет предоставляет соответствующую зависимость \verb|Provides: /usr/foo|.
\item Если в пакете запакован файл (или каталог) \verb|/usr/foo|.
\end{itemize}
Таким образом, преимуществом файловых зависимостей является то, что их не нужно явно <<предоставлять>>~---
они предоставляются <<по факту>> наличия файлов в пакете.  Исключением являются <<альтерантивы>>, то есть
символические ссылки, создаваемые при установке программой \verb|update-alternatives| (такие пути должны
быть предоставлены через \verb|Provides|).

Другим преимуществом файловых зависимостей является то, что во многих случаях они являются наиболее точным
выражением \verb|Requires| зависимостей.  Например, если в каком-либо perl-скрипте имеется shebang-инструкция
\verb|#!/usr/bin/perl|, то работоспособность такого скрипта напрямую зависит от наличия интерпретатора \verb|/usr/bin/perl|.
Вместо зависимости на \verb|/usr/bin/perl| можно было бы указать зависимость на пакет \verb|perl-base| (или \verb|perl|,
если в дистрибутиве нет пакета \verb|perl-base|), но такая зависимость оказалась бы менее точной, т.\,к. она не гарантирует
напрямую наличие интерпретатора \verb|/usr/bin/perl| (кроме того, как уже видно, не всегда можно установить однозначное
соответствие между интерпретатором и именем пакета).

Хуже того, при сборке некоторых пакетов генерируются shebang-инструкция с указанием версии интерпретатора: \verb|#!/usr/bin/perl5.14.2|.
Если вместо файловой зависимости для такой инструкции сгенерировать зависимость на \verb|perl-base|, то эта зависимость
окажется не только неточной, но и очень хрупкой.  Зададимся вопросом: что будет при обновлении perl до новой версии?
Если была сгенерирована файловая зависимость, то при обновлении у пакетов с такой инструкцией появится неудовлетворенная
зависимость (и пакеты нужно будет пересобрать).  Если же сгенерировать зависимость на имя пакета, то обновление пройдет
без нарушения зависимостей, но пакеты утратят работоспособность~--- скрипты перестанут запускаться ввиду отсутствия
интерпретатора!  А это довольно неприятное последствие~--- получаются, что зависимости, которые
должны давать хотя бы минимальную гарантию работоспособности программы, на самом деле не дают и минимальной гарантии.

Таким образом, мы считаем, что файловые зависимости использовать не только уместно, но и необходимо во всех случаях,
когда зависимость может быть однозначно выражена в виде пути к файлу.

Хотя rpm полностью поддерживает файловые зависимости на базовом уровне (на уровне проверки зависимостей),
некоторые системы на основе rpm не поддерживают файловые зависимости как следует~--- не учитывают того,
что файловые зависимости могут разрешаться через обычные файлы, а не только через \verb|Provides|.
Дело в том, что при работе с репозиторием пакетов общий список файлов во всех пакетах может оказаться
довольно большим, и его обрабтка представляет некоторую сложность.  Рассмотрим два характерных случая:
\begin{itemize}
\item Система доступа к репозиторию вообще не учитывает файлов, запакованных в пакете, а учитывает только явные \verb|Provides|.
В системах такого рода нужно либо добавить <<распознавание>> файлов, либо вместо этого добавлять некоторые файловые пути прямо
в \verb|Provides|.  Однако, например, \verb|apt-rpm| изначально поддерживает файловые зависимости, так что для корректной работы
не требуется модификации клиентских программ.
\item Файловые зависимости не учитываются при <<индексировании>> репозитория, т.\,е. список файлов игнорируется при создании
метаинформации.  Как ни странно, этот случай характерен для \verb|apt-rpm|, и в одном российском дистрибутиве пришлось довольно
серьезно переделать процедуру генерации репозитория.  В таких системах порождение метаинформации должно выполняться в два
прохода: на первом проходе надо искать файловые зависимости, чтобы на втором проходе сохранить частичные списки файлов.
\end{itemize}
В связи с генерацией репозитория нужно учитывать еще один важный случай:
\begin{itemize}
\item Последовательная оверлейная сборка пакетов.  Пусть мы собираем пакеты на репозитории с корректной, но частичной
поддержкой файловых зависимостей.  Собранные пакеты помещаются в оверлейный репозиторий, который также используется
при сборке.  Тогда при сборке пакета A может образоваться файловая зависимость, для разрешения которой не хватает информации
в основном репозитории.  После этого не может быть выполнена сборка пакета B, который требует для сборки пакет A,
т.\,к. пакет A не может быть установлен.  В общем случае поддержка оверлейной сборки (двух и более пакетов) требует,
чтобы основной репозиторий был перегенирирован с полной информацией о файлах (именно такой подход используется в одном
российском дистрибутиве).
\end{itemize}
Итак, сборочная система и система доступа к репозиторию должны как следует поддерживать файловые зависимости.

Файловые зависимости генерируются не только для shebang-инструкций (см. раздел \ref{shebang-req}),
но и, например, при обработке символических ссылок (см. раздел \ref{symlinks-req}).  Для порождения
файловых зависимостей разработана вспомогательная библиотека шелл-функций \verb|/usr/lib/rpm/find-package|.
Изначально библиотека использовалась для анализа зависимостей в шелл-скриптах, поэтому основная процедура
\verb|FindPackage| на самом деле используется как для порождения файловых зависимостей, так и зависимостей
для \textit{команд}, т.\,е. для программ, вызываемых по имени (без указания полного пути программы).

При порождении файловых зависимостей в \verb|find-package| выполняется \textit{канониклизация} пути.
При этом должны быть учтены некоторые особенности сопоставления путей в каталоге \verb|%buildroot|
и в хост-системе.  Например, во многих дистрибутивах путь \verb|/etc/init.d| является символической
ссылкой, указывающей на каталог \verb|/etc/rc.d/init.d|.  Тогда, если в каком-либо скрипте загружается
файл \verb|/etc/init.d/functions|, то с учетом символической ссылки \verb|/etc/init.d|
должна быть сгенерирована файловая зависимость на \verb|/etc/rc.d/init.d/functions|.
Во многих других случаях, однако, содержимое каталога \verb|%buildroot| должно иметь приоритет над
содержимым корневой файловой системы.

Генерация зависимостей для команд рассмотрена в следующем разделе.

\section{Зависимости шелл-скриптов}
\label{shell-req}
Поднобнее остановимся на анализаторе зависимостей шелл-скриптов \verb|shell.req|, т.\,к. при
его реализации возникают вопросы, в разной степени характерные для многих других методов
поиска зависимостей.

Первичный анализ скрипта выполняется интерпретатором \verb|/bin/sh| с опцией \verb|--rpm-requires|,
т.\,е. задействуется специальный режим анализа кода, производный от режима проверки синтаксиса \verb|sh -n|.
Таким образом, дополнительным преимуществом \verb|shell.req| следует считать синтаксическую проверку
кода, выполняемую при поиске зависимостей.  Обнаружение синтаксических ошибок в скриптах можно отнести
к дополнительному тестированию, выполняемому при сборке (если \verb|shell.req| обнаруживает синтаксическую ошибку,
то сборка пакета завершается с ошибкой).  Проверка синтаксиса особенно важна для \%post-скриптов (см. раздел
\ref{post-script-deps}).

Особенностью шелл-скриптов является отсутствие специального механизма для указания требований (такого, как подключение
модулей в других языках программирования)~--- фактически, каждая \textit{команда} может порождать некоторую зависимость.
Вместе с отсутствием специального механизма исключений, который мог бы использоваться для условной загрузки кода,
это обостряет проблему порождения \textit{условных завсимостей}.  Например, для кода
\begin{verbatim}
if [ -f /etc/foo.conf ]; then
        . /etc/foo.conf
fi
if [ -f /usr/local/foo.conf ]; then
        . /usr/local/foo.conf
fi
\end{verbatim}
будут порождены файловые зависимости на \verb|/etc/foo.conf| и \verb|/usr/local/foo.conf|, при том,
что обе зависимости являются условными, а вторая~--- недопустимой (т.\,к. иерархия \verb|/usr/local|
не должна использоваться в пакетах).

Существует несколько способов, с помощью которых можно избежать порождения условных зависимостей:
\begin{itemize}
\item Можно переписать код таким образом, чтобы зависимось не порождалась.
Для этого можно <<спрятать>> команду или значение аргумента в переменную
\begin{verbatim}
foo=/usr/local/foo.conf
if [ -f $foo ]; then
        . $foo
fi
\end{verbatim}
либо дополнить команду специальным присваиванием, которое распознается анализатором
как инструкция игнорировать команду:
\begin{verbatim}
if [ -f /usr/local/foo.conf ]; then
        a= . /usr/local/foo.conf
fi
\end{verbatim}
Заметим, что в силу особенностей реализации интерпретатора зависимости в \textit{подстановках команд},
т.\,е. зависимости в конструкциях вида \verb|$(cmd ...)| также игнорируются.
\item Можно отфильтровать ненужные зависимости, используя специальные макросы в спекфайле
(см. раздел \ref{filter-deps}).
\item Для пакетов типа \verb|contrib| (содержащих скрипты, которые не предназначены для
непосредственного запуска пользователем) поиск шелл-зависимостей можно отключить:
\texttt{AutoReq: yes, noshell}.  Однако для пакетов, не относящихся к категории \verb|contrib|,
полностью отключать \verb|shell.req| не следует, т.\,к. желательно сохранить синтаксическую
проверку.  Вероятно, для такого класса пакетов нужно реализовать специальный режим
\texttt{AutoReq: yes, shell=syntax-check-only}.
\end{itemize}

Итак, синтаксический анализ позволяет обнаружить \textit{команды}, используемые в скрипте (аргументы некоторых стандартных команд,
как в примере с \verb|foo.conf|, также считаются командами).  Если команда имеет вид \textit{пути к файлу}, то для такой команды
\verb|find-package| порождает файловую зависимость; оставшиеся \textit{простые} команды подразделяются анализатором
на два вида: шелл-функции и исполняемые файлы.

Для простых команд выполняется \textit{элиминация зависимостей на функции}: формируется глобальный список шелл-функций,
которые определены в каком-либо файле в пределах пакета.  В дальнейшем команды с названием этих функций исключаются
из поиска зависимостей.  Дело в том, что интерпретатор не всегда может заранее определить, является ли вызываемая
команда функцией или исполняемым файлом.  Для реализации этой стадии требуется модифицировать режим \verb|--rpm-requires|
таким образом, чтобы в качестве зависимостей выводились не только вызываемые, но и все определяемые функции.

Оставшиеся команды считаются исполняемыми файлами, которые должны быть расположены в стандартных каталогах \verb|PATH|.
При формировании зависимостей для таких команд возникает следующее противоречие: с одной стороны, команды могут
перемещаться между каталогами (например, программу можно переместить из каталога \verb|/usr/bin| в каталог \verb|/bin|),
и тогда в качестве зависимости лучше использовать имя пакета.  В то же время файлы могут перемещаться между
подпакетами (например, программы из базового подпакета могут быть перенесены в дополнительный подпакет), и тогда
зависимость на имя пакета не гарантирует наличия команды.  Можно было бы использовать отдельное пространство имен
для исполняемых команд~--- \verb|command(foo)|, однако при этом теряется различие между \verb|sbin|-командами,
доступными только пользователю \verb|root|, и \verb|bin|-командами, доступными всем пользователям.  Поэтому
сейчас реализован компромиссный вариант, в котором по умолчанию генерируется зависимость на имя пакета.

Однако команда не всегда может быть однозначно сопоставлена с именем пакета.  Если приоритетный путь \verb|/usr/bin/foo|
предоставляется двумя пакетами с разным именем (обычно такой путь является <<альтернативой>>, хотя возможны и конфликтующие
реализации), то нужно сгенерировать файловую зависимости на \verb|/usr/bin/foo|.  Если же два разных пути находятся
в одном пакете (например, \verb|/bin/foo| и \verb|/usr/bin/foo|~--- обычно один из путей в таком случае является символической
ссылкой), то лучше сгенерировать зависимость на имя пакета.  При этом \textit{приоритет путей} может быть разным: для скриптов,
расположенных в каталогах \verb|/sbin|, \verb|/usr/sbin| и в некоторых других системных каталогах поиск команд выполняется
в порядке
\verb|/sbin|, \verb|/bin|, \verb|/usr/sbin|, \verb|/usr/bin|,
а для остальных скриптов~--- в порядке
\verb|/bin|, \verb|/sbin|, \verb|/usr/bin|, \verb|/usr/sbin|.
Как видно, различие между \verb|sbin|-скриптами и \verb|bin|-скриптами не является строгим~---
каталоги \verb|/sbin| и \verb|/usr/sbin| используются в обоих случаях.

Понятно, что результат поиска команды может зависеть не только от пакетов, установленных при сборке.  В частности,
по установленным пакетам нельзя определить, для каких команд имеются конфликтующие реализации.  Поэтому при сборке
пакета сборочная система формирует \textit{глобальный индекс команд} для всех пакетов в репозитории, который
мы называем \verb|contents_index_bin|.  Алгоритм \verb|find-package|, как правило, использует этот индекс в приоритетном
порядке (чтобы сформировать достаточно общие зависимости для команд, имеющих альтернативные и конфликтующие реализации).

Однако существует несколько реальных команд, как в следующем примере, у которых отличается как путь, так и название
пакета.
\begin{verbatim}
/usr/bin/arpsend        arpsend
/usr/sbin/arpsend       vzctl
\end{verbatim}
В таких случаях с помощью \verb|contents_index_bin| уже нельзя сформировать зависимость достаточно общего вида~---
придется делать выбор в пользу одной из конкретных реализаций.  Поэтому в таких случаях приоритет при поиске снова
отдается установленным пакетам, т.\,к. нужная реализация, возможно, используется при сборке пакета.

Необходимо заметить, что использование глобального индекса нарушает принцип \textit{воспроизводимости} сборки:
результат сборки пактов должен зависеть только от исходного кода и от пакетов, используемых при сборке (т.\,е. от пакетов,
установленных в сборочный чрут для <<чистовой>> сборки).  При использовании глобального индекса команд получается,
что зависимости пакета могут в некоторой степени зависеть и от других пакетов в репозитории.  Поэтому, во-первых,
политика дистрибутива должна ограничивать размещение <<левых>> команд в стандартных каталогах \verb|PATH|.  Во-вторых,
если сборочная система строго конролирует инвариант перехода (см. введение) и, в частности, фиксирует любые изменения
зависимостей у пакетов после тестовой пересборки, то нужно реализовать дополнительных механизм контроля зависимостей,
которые могут измениться только из-за содержимого \verb|contents_index_bin|.

В последнее время появились предложения по объединению каталогов \verb|/bin| и \verb|/sbin| с каталогами в иерархии \verb|/usr|.
В связи с этим некоторые подходы, описанные в данном разделе, могут быть пересмотрены.
\pagebreak

\section{Сборка perl-пакетов~--- rpm-build-perl}
Модульный подход, обозначенный в разделе \ref{modular-approach}, позволяет независимо разрабатывать
компоненты, дополняющие базовую политику сборки.  Одним из таких компонентов является пакет \verb|rpm-build-perl|.
В этот пакет вынесены скрипты поиска зависимостей и еще несколько файлов, относящихся к языку perl или направленных
на поддержку сборки perl-пакетов.  При этом в пакет \verb|rpm-build| добавлена зависимость на \verb|rpm-build-perl|~---
таким образом, поддержка perl-зависимостей сохранена для всех пакетов.  Некоторые другие расширения,
однако, не могут быть внесены в базовую сборочную среду; для таких расширений должна быть продумана специальная
схема поддержки зависимостей (см. \verb|rpm-build-mono| в разделе \ref{rpm-build-mono}).

Пакет \verb|rpm-build-perl| содержит следующие компоненты:
\begin{itemize}
\item Скрипт формирования Requires зависимостей \verb|perl.req| и соответствующий ему скрипт отбора файлов \verb|perl.req.files|.
\item Скрипт формирования Provides зависимостей \verb|perl.prov| и соответствующий ему скрипт отбора файлов \verb|perl.prov.files|.
\item Скрипт \verb|perl.clean| для очистики каталога \verb|%buildroot| на стадии brp.
\item Файл \verb|perl.def| с макросами, которые используются при сборке perl-пакетов.
\item Файл \verb|perl.env| для управления параметрами сборки (см. раздел \ref{perl-env-intro}).
\end{itemize}

По сравнению с традиционной реализацией было изменено представление зависимостей для модулей:
вместо \verb|perl(File::Spec)| используются зависимости вида \verb|perl(File/Spec.pm)|,
т.\,е. вместо имени модуля используется соответствующие компоненты имени файла.
Таким образом, выбрано унифицированное представление зависимостей для модулей и зависимостей
вида \verb|perl(getopts.pl)| и \verb|perl(sys/ioctl.ph)|.

Кратко остановимся на некоторых особенностях сборки perl-пакетов.  Базовая совместимость модулей
с интерпретатором выражается через зависимости на каталоги (см. раздел \ref{files-req}), при этом
не используется версионирование каталогов (механизм \verb|inc_version_list|
отключен при сборке интерпретатора).  Вообще, структура каталогов для модулей подвергнута максимальному упрощению.
Так, все модули из noarch пакетов располагаются в каталоге \verb|/usr/share/perl5|, так что результат
сборки таких пакетов, как правило, не зависит от версии интерпретатора.  Однако для компилируемых
модулей зависимости на каталог \verb|/usr/lib/perl5| или \verb|/usr/lib64/perl5| будет недостаточно.
Процедура сборки perl-расширений модифицирована таким образом, чтобы загружаемые объекты \verb|.so| компоновались
с библиотекой libperl.  А библиотека libperl в свою очередь наделяется именем (soname) вида \verb|libperl-5.14.so|.
Таким образом, бинарная совместимость модулей и интерпретатора конролируется стандартным способом~--- через
зависимости на soname библиотеки, при этом также используются set-версии (см. раздел \ref{set-versions}).
Всё это позволяет сформировать более \textit{точные} и менее \textit{жесткие} зависимости, которые позволяют
контролировать не только \textit{обратную}, но и \textit{прямую} совместимость (например,
бинарную совместимость модуля, собранного с новой версией интерпретатора, с более старой версией интерпретатора).

\subsection{Анализатор зависимостей perl.req}

Загрузка модулей в языке perl выполняется с помощью функции \verb|require| или
инструкции \verb|use| (которая сводится к вызову функции \verb|require|).
В традиционной реализации скрипт \verb|perl.req| с помощью регулярного
выражения ищет строки, которые начинаются со слов \verb|require| или \verb|use|,
и выполняет дальнейший разбор этих строк.

Рассмотрим фрагмент традиционной реализации \verb|perl.req|.
\begin{verbatim}
if (m/^(\s*)         # we hope the inclusion starts the line
    (require|use)\s+(?!\{)     # do not want 'do {' loops
    # quotes around name are always legal
    ['"]?([^; '"\t#]+)['"]?[\t; ]
    # the syntax for 'use' allows version requirements
    # the latter part is for "use base qw(Foo)" and friends special case
    \s*($modver_re|(qw\s*[(\/'"]\s*|['"])[^)\/"'\$]*?\s*[)\/"'])?
    /x)
) {
my ($whitespace, $statement, $module, $version) = ($1, $2, $3, $4);

# we only consider require statements that are flushed against
# the left edge. any other require statements give too many
# false positives, as they are usually inside of an if statement
# as a fallback module or a rarely used option
($whitespace ne "" && $statement eq "require") && next;

# skip if the phrase was "use of" -- shows up in gimp-perl, et al.
next if $module eq 'of';
\end{verbatim}
Как видно, регулярное выражение нельзя назвать простым.  Кроме того, регулярного выражения оказывается недостаточно.
Язык perl характеризуется очень сложным синтаксисом~--- неоднородной системой кавычек и ограничителей, многострочными
литералами here-documents, наконец, встроенной документацией pod.  Не случайно последняя проверка в приведенном фрагменте
<<отсеивает>> типичное вхождение слова <<use>> в предоложения английского языка (в дальнейшем выполняется еще несколько
похожих проверок).  Обращает на себя внимание и первая проверка: она оставляет только строки без отступа (а строки с отступом
считаются условными конструкциями).  Однако отступы в языке perl не являются значащами.  Кроме того, уровень вложенности
не всегда означает условную конструкцию, как в следующем типичном примере:
\begin{verbatim}
BEGIN {
    use Exporter;
    @EXPORT = qw(foo bar);
}
\end{verbatim}
Следует также отметить, что инструкции \verb|use| выполняются всегда (на стадии загрузки кода),
и поэтому понятие условных конструкций к ним не относится.

Таким образом, разбор кода на языке perl с помощью регулярных выражений нельзя считать надежным подходом.
Вообще, как говорят хакеры, <<Only perl can parse perl>>, т.\,е. надежный разбор кода на языке perl
может быть выполнен только средствами самого интерпретатора perl.

К счастью, интерпретатор предоставляет доступ к внутреннему представлению кода.  При загрузке кода
интерпретатор формирует дерево опкодов (которое обладает как признакми синтаксического дерева,
так и признаками байткода); в дальнейшем дерево <<выполняется>> с помощью отдельной процедуры (которую
можно считать прототипом виртуальной машины).  Модуль \verb|B|, иногда называемый <<компилятором>>,
предоставляет доступ к дереву опкодов, а также позволяет отключить основную стадию исполнения кода
(активизируя режим проверки синтаксиса \texttt{perl -c}).  Модуль \verb|O| иногда называют <<интерфейсом
компилятора>>~--- он упрощает загрузку дополнительных модулей, работающих в <<режиме компилятора>>.

Модуль \verb|B::Concise| позволяет отобразить дерево опкодов:
\begin{verbatim}
$ perl -MO=Concise -e 'require Foo; print 1'
9  <@> leave[1 ref] vKP/REFC ->(end)
1     <0> enter ->2
2     <;> nextstate(main 1 -e:1) v:{ ->3
4     <1> require sK/1 ->5
3        <$> const[PV "Foo.pm"] s/BARE ->4
5     <;> nextstate(main 1 -e:1) v:{ ->6
8     <@> print vK ->9
6        <0> pushmark s ->7
7        <$> const[IV 1] s ->8
-e syntax OK
\end{verbatim}

Дерево опкодов сохраняет всю важную информацию об исходном коде.
Модуль \verb|B::Deparse| позволяет реконструировать исходный код:
\begin{verbatim}
$ perl -MO=Deparse -e 'require Foo; print 1'
require Foo;
print 1;
-e syntax OK
\end{verbatim}

Идея <<нетрадиционной>> реализации \verb|perl.req| состоит в том, чтобы вместо регулярного выражения
использовать для извлечения зависимостей вспомогательный модуль \verb|B::PerlReq| (разработанный специально
для этой цели):
\begin{verbatim}
$ perl -MO=PerlReq -e 'require Foo; print 1'
perl(Foo.pm)
-e syntax OK
\end{verbatim}

Основным источником зависимостей в дереве опкодов являются опкоды \verb|require|, которые соответствуют
непосредственным вызовам функции \verb|require| и инструкциям \verb|use|.  Однако к образованию зависимостей
могут приводить и некоторые другие конструкции.  Например, версионирование зависимостей осуществляется
с помощью вызова статического метода \verb|VERSION|: инструкция вида
\begin{verbatim}
use Module 1.0 qw(list);
\end{verbatim}
на самом деле <<раскрывается>> в код
\begin{verbatim}
BEGIN {
    require Module;
    Module->VERSION(1.0);
    Module->import(list);
}
\end{verbatim}
Поэтому в модуле \verb|B::PerlReq| в качестве общего случая реализован анализ вызовов функций
и статических методов (в том числе выполняется реконструкция константных аргументов).  Это
позволяет обнаруживать отложенную загрузку модулей вида
\begin{verbatim}
use autouse Foo => qw(bar baz);
\end{verbatim}
за счет обработки вызова статического метода \verb|autouse->import|:
\begin{verbatim}
$ perl -MO=PerlReq -e 'use autouse Foo => qw(bar baz)'
perl(autouse.pm)
perl(Foo.pm)
-e syntax OK
\end{verbatim}

Анализ вызова функций и статических методов позволяет обнаружить довольно сложные способы образования
зависимостей.  Например, в следующих двух случаях
\begin{verbatim}
open $fh, ">", \$var;
IO::File->new(\$var, "w");
\end{verbatim}
при открытии файла вместо имени файла передается ссылка на переменную \verb|$var|.
В таких случаях доступ к файлу на диске заменяется доступом к содержимому переменной \verb|$var| (т.\,н. in-memory files).
Примитивы доступа к таким псевдофайлам реализованы в модуле \verb|PerlIO::scalar|, который загружается интерпретатором
по мере необходимости.  Соответствено, при обнаружении подобных конструкций модуль \verb|B::PerlReq| порождает зависимость
на \verb|perl(PerlIO/scalar.pm)|.

Подробнее рассмотрим проблему условных зависимостей.  Функция \verb|require|, которая выполняет загрузку модулей, всегда
возвращает истинное значение.  Если же модуль загрузить не удается, то функция \verb|require| генерирует исключение, которое,
как правило, приводит к аварийному завершению программы.  Единственный способ перехватить исключение~--- заключить вызов
\verb|require| в блок \verb|eval|.  Это определяет основное правило обработки условных зависимостей, принятое в модуле
\verb|B::PerlReq|: условными считаются только зависимости, которые возникают внутри блоков \verb|eval| (такие зависимости игнорируются).
В то же время не игнорируются, например, зависимости на модули, загружаемые внутри функций, если вызовы \verb|require| в функциях
не <<защищены>> блоком \verb|eval|.

Одна из проблем при таком подходе, однако, связана с тем, что для условных зависимостей часто характерна <<обратная логика>>.
Рассмотрим следующий пример:
\begin{verbatim}
eval {
    require Foo;
};
if ($@) {
    # Foo not available, fall back to Bar
    require Bar;
}
\end{verbatim}
В этом примере предпринимается попытка загрузить модуль \verb|Foo|, а модуль \verb|Bar| загружается только в случае,
если модуль \verb|Foo| загрузить не удалось.  В соответствии с логикой обработки условных зависимостей будет сгенерирована
зависимость \verb|perl(Bar.pm)|.  Однако <<по смыслу>> более предпочтительной была бы зависимость \verb|perl(Foo.pm)|~---
если модуль \verb|Foo| существует и его удается загрузить.

Понятно, что в общем случае проблему <<обратной логики>> условных зависимостей решить довольно сложно~--- потребовалось
бы реализовать предсказание переходов.  Однако в некоторых случаях, продолжая аналогию <<Only perl can parse perl>>, можно
рассчитывать на исполнение кода самим интерпретатором.  Например, поскольку блоки \verb|BEGIN| выполняются только один раз и
в безусловном порядке, то при обработке блоков \verb|BEGIN| можно просто проверять (через \verb|%INC|), какие модули были
фактически загружены интерпретатором.  Аналогичная возможность может быть распространена на <<основной код>> модулей
(код инициализации), если реализовать специальный режим загрузки модулей \verb|modexec|, при котором не только загружается
текст, но и выполняется код инициализации (режим \verb|modexec| пока не реализован, однако трудности реализации не являются
принципиальными).  В то же время режим исполнения кода не может быть распространен на скрипты, т.\,к. выполнение
скриптов обычно связано с побочными эффектами.

\subsection{Макросы и автоматизация сборки}
\label{perl-macros}

В данном разделе рассматривается сборка perl-модулей, распространяемых через CPAN.
Сборка пакетов выполняется по одинаковой схеме:
\begin{verbatim}
%prep
%setup -q -n Foo-%version

%build
perl Makefile.PL INSTALLDIRS=vendor
make

%check
make test

%install
make install DESTDIR=%buildroot

%files
%perl_vendorlib/Foo*
\end{verbatim}

В некоторых пакетах, однако, вместо \verb|Makefile.PL| используется \verb|Build.PL|;
в таких пакетах сборка идет по другой схеме: вместо \verb|Makefile| создается скрипт \verb|Build|,
который используется в качестве самостоятельной программы вместо \verb|make(1)|.

Можно реализовать вспомогательные макросы, в которых выбор нужной схемы сборки будет выполняться
автоматически.  Тогда соответствующие секции спекфайла будут выглядеть следующим образом:
\begin{verbatim}
%build
%perl_build

%check
%perl_check

%install
%perl_install
\end{verbatim}
В результате мы получаем не только максимальное \emph{упрощение}, но и максимальную \emph{унификацию}
сборки perl-пакетов.  А унификация важна сама по себе: лишние степени свободы
далеко не всегда могут быть использованы для улучшений, зато часто являются источником <<разнобоя>>.
Последовательность команд для сборки, даже правильная, всегда может стать предметом для проверки.
А если сборка полностью унифицирована, то в этом отношении в пакетах попросту <<нечего исправлять>>.

Кроме того, что полученная конструкция является унифицированной, ее можно считать достаточно \emph{надежной}:
почти все пакеты содеражат тесты, которые выполняются при сборке; зависимости должны обеспечить
работоспособность пакета при установке; а также поиск зависимостей подразумевает синтаксическую проверку кода
(режим \verb|modexec| должен дополнительно гарантировать загружаемость модулей).
Таким образом, получить в результате использования этой конструкции неработоспособный пакет довольно сложно.

Дальнейшая автоматизация сборки связана с возможностями, предоставляемыми CPAN.
CPAN экспортирует информацию о модулях в хорошо структурированном виде, что позволяет
вычислить список модулей, которые должны быть обновлены:
\begin{verbatim}
$ perl -MCPAN -e 'CPAN::Shell->r'
Package namespace  installed  latest  in CPAN file
AnyEvent                6.02    6.12  MLEHMANN/AnyEvent-6.12.tar.gz
Apache::DBI             1.10    1.11  PHRED/Apache-DBI-1.11.tar.gz
Archive::Extract        0.56    0.58  BINGOS/Archive-Extract-0.58.tar.gz
...
\end{verbatim}

Следует отметить, что в любом современном дистрибутиве должно быть порядка 1000 perl-пакетов (пакеты, на которые существует <<спрос>>).
Понятно, что автоматизация обновления perl-пакетов в таком случае становится довольно актуальной задачей.  Однако системы
автоматизированного обновления perl-пакетов, которая целиком бы нас устраивала, пока не создано.
Дальнейшее обсуждение автоматизации сборки выходит за рамки данного документа.  Заметим только, что при автоматизации
должна быть сохранена возможность проверки пакета человеком~--- перед тем, как пакет будет направлен в репозиторий.
Таким образом, \emph{автоматизированное} обновление не означает \emph{слепое} обновление.

\section{Зависимости на ELF-библиотеки, set-версии}
Исполняемые файлы и разделяемые библиотеки в формате ELF являются основной реализации пользовательского пространства ОС.
Формат ELF также является основой спецификации System~V Application Binary Interface, которая является составной частью
UNIX и Linux стандартов.  Следует отметить, что формат ELF реализует низкоуровневые возможности и не предоставляет механизма
обработки ошибок и исключительных ситуаций: в нештатной ситуации~--- например, при обнаружени несовместимости~--- работа
приложения аварийно завершается.  Поэтому поддержку бинарной совместимости можно считать приоритеной задачей для системы
управления пакетами.  Перефразируя
\emph{тезис Силина},\footnote{\textit{Расходы, затраченные на управление виртуальной памятью, окупаются.}
Игорь Силин~--- разработчик ОС <<Дубна>> для БЭСМ-6.}
можно сказать, что расходы, затраченные на поддержку бинарной совместимости, окупаются.

В современных дистрибутивах Linux программы \emph{динамически} компонуются с разделямыми библиотеками.
Запуск таких программ выполняется с помощью вспомогательной программы~--- загрузчика \verb|ld.so|,
который конструирует исполняемый образ программы (полный путь к загрузчику содержится в сегменте \verb|PT_INTERP| программы).
При этом происходит загрузка необходимых разделяемых библиотек (список библиотек содержится в секции \verb|DT_NEEDED| программы).
Разделяемые библиотеки в свою очередь могут требовать другие разделяемые библиотеки.  После того, как все требуемые библиотеки
загружены, загрузчик выполняет проверку версионированных интерфейсов~--- наличие интерфейсов типа \verb|GLIBC_2.4| (информация
о которых содержится в секциях \verb|DT_VERDEF| и \verb|DT_VERNEED|).  После этого выполняется подготовка к запуску, и загрузчик
передает управление в стартовую процедуру программы.  \emph{Разрешение символов} обычно выполняется во время работы программы:
поиск функции по имени выполняется при первом обращении к функции.

Таким образом, чтобы обеспечить бинарную совместимость динамически компонуемых программ и разделяемых библиотек,
rpm должен фактически следовать логике загрузчика \verb|ld.so|.  А именно, rpm должен контролировать следующие
аспекты совместимости:
\begin{itemize}
\item Возможность загрузки необходимых разделяемых библиотек.
\item Наличие необходимых версионированных интерфейсов.
\item Разрешимость символов во время работы программы.
\end{itemize}

Традиционно rpm контролирует только первые два аспекта совместимости (особенности реализации обсуждаются
далее в разделе \ref{lib-namespace}).  Последний аспект является новым: поддержка зависимостей, в которых учитыается
информация о символах, была реализована относительно недавно (релизация рассмотрена в разделе \ref{set-versions}).

\subsection{Пространство имен библиотек}
\label{lib-namespace}
В традиционной реализации для всех библиотек используется глобальное пространство имен, независимо
от каталога, в котором расположена библиотека, и без учета назначения библиотеки.  Это порождает
много ненужных Provides зависимостей.

Например, пакет \verb|perl-XML-LibXSLT-1.700.0-4-mdv2011.0.x86_64.rpm| предоставлят зависимость \verb|Provides: LibXSLT.so()(64bit)|,
которая соответствует файлу \texttt{/usr/lib/perl5/.../auto/XML/LibXSLT/LibXSLT.so}.  Однако этот файл не является <<библиотекой>>
общего назначения в том смысле, что он не предназначен для динамической компоновки и не будет загружаться через \verb|DT_NEEDED|.
Это файл является <<плагином>> для интерпретатора perl и будет загружаться через \verb|dlopen(3)|.  Поэтому он расположен
в специальном каталоге, в котором его будет искать интерпретатор.

Эта проблема лишних зависимостей уже обратила на себя внимание.  Так, в проекте Fedora реализован макрос для
фильтрации зависимостей \verb|%perl_default_filter|, который нужно добавлять в спекфайлы perl-пакетов.

Проблему лишних зависимостей, однако, не следует понимать исключительно как проблему оптимизации.
Зависимости имен библиотек неявно образуют пространство имен.  Это пространство имен наделяется
определенной семантикой: если какой-либо пакет требует зависимость вида \verb|libfoo.so.1|,
то он рассчитывает, что динамический загрузчик сможет загрузить эту библиотеку в конфигурации
по умолчанию (т.\,е. библиотека должна быть найдена в стандартном системном каталоге);
соответственно, если какой-либо пакет предоставляет зависимость \verb|libfoo.so.1|,
то библиотека \verb|libfoo.so.1| должна стать доступна в конфигурации по умолчанию, т.\,е.
располагаться в стандартном системном каталоге.  С другой стороны, какой-либо пакет может
содержать копию библиотеки \verb|libfoo.so.1| в своем <<приватном>> каталоге (такая практика
не поощряется, но в принципе пакет <<имеет право>> содержать в приватном каталоге любые библиотеки).
Такие приватные библиотеки не должны влиять на разрешение системных зависимостей.

Таким образом, мы предлагаем использовать пространство имен вида \verb|libfoo.so.1| только для
библиотек, доступных в конфигурации по умолчанию, т.\,е. для библиотек, расположенных в каталогах
\verb|/lib|, \verb|/usr/lib| (на архитектуре i686) и в каталогах \verb|/lib64|, \verb|/usr/lib64|
(на архитектуре x86\_64).

В некоторых случаях, однако, динамический загрузчик может загружать библиотеки из нестандартных
каталогов~--- например, при использовании в исполняемом файле пути к библиотекам \verb|RPATH|.
Для указания зависимостей на такие библиотеки можно использовать файловые зависимости~---
зависимости вида \texttt{Requires: /usr/foo/libfoo.so.1} (см. раздел \ref{file-deps}).
Преимуществом таких зависимостей является то, что для их разрешения не требуется соответствующих
Proivdes зависисимостей~--- достаточно фактического наличия нужного файла в каталоге \verb|/usr/foo|.

Недостатком же файловых зависимостей является отсуствие версионирования~--- в предолженной схеме
с использованием простых файловых зависимостей невозможно выразить требования на версионированные
интерфейсы и на символы.  Поэтому в некоторых случаях файловые зависимости могут <<наращиваться>>
соответствующими Provides зависимостями, сформированными на основе имени файла, т.\,е. зависимостями
вида \texttt{Provides: /usr/foo/libfoo.so.1(FOO\_1.0)}.  При этом префикс \verb|/usr/foo| можно также
трактовать как пространство имен, которое отделяет библиотеку \verb|libfoo.so.1| от стандартного
пространства имен.

Для <<наращивания>> зависимостей в спекфайле с помощью макроса должен быть задан каталог
с приватными библиотеками: \verb|%add_findprov_lib_path /usr/foo|.

Если приватные библиотеки используются только внутри пакета (или внутри подпакетов одного пакета),
то <<наращивания>> зависимостей не требуется: будет сформирована файловая зависимость, которая в дальнейшем должна
быть оптимизирована (в том числе и в подпакетах, которые связаны строгими зависимостями~--- см. раздел \ref{deps-optimization}).
<<Наращивание>> полезно только в случаях, когда библиотеки, расположенные в нестандартном каталоге, активно используются
другими пакетами.  Однако такие случаи редки, и обычно такие библиотеки следует переносить в системный каталог.

К спорным особенностям реализации зависимостей можно отнести возможность использования дополнительных <<стандартных>> каталогов.
С одной стороны, загрузчик \verb|ld.so| предоставляет стандарнтую возможность добавления каталогов
через файлы конфигурации \verb|/etc/ld.so.conf| и \verb|/etc/ld.so.conf.d/*|.  С другой стороны, использование этой возможности
требует дополнительного конторля конфигурации \verb|ld.so|.  Фактически требуется контролировать содержимое конфигурационных
файлов \verb|ld.so.conf|~--- чтобы в одном из них всегда был указан нужный каталог.  Однако rpm допускает модификацию
конфигурационных файлов.

\subsection{Версионирование интерфейса, set-версии}
\label{set-versions}
При разработке ПО большое внимание уделяется обратной совместимости.  \emph{Обратная совместимость}
означает, что новая версия разработанного компонента ПО будет работать в старом окружении~--- сохраняет совместимость.
Однако обратная совместимость не может обеспечить все \emph{реальные} требования совместимости.  Вообще,
при запуске программы не существует <<обратой>> совместимости, а существует \emph{просто совместимость}.
Если компоненты программы совместимы, то она будет работать.  А в противном случае компоненты программы несовместимы,
и программу следует считать неработоспособной.

Ситуации, когда обратной совместимость оказывается недостаточно, часто возникают при использовании разделяемых
библиотек.  Это связано с тем, что версии пакетов могут обновляться асинхронно и использоваться в разных комбинациях,
не предусмотренных хронологией разработки.  Поясним это на следующем примере.  Разработчик библиотеки, добавляя новые функции в библиотеку,
считает, что он сохраняет обратную совместимость~--- существующие программы будут работать с новой версией библиотеки.
Однако пользователь репозитория пакетов обычно хочет обновить интересную ему программу.  Тогда в комбинации <<новая программа
со старой библиотекой>> могут образоваться неразрешимые символы (при обнаружении неразрешимых символов программа аварийно завершается).

Таким образом, требования обратной совместимости часто должны быть дополнены требованием <<минимальной версии>> библиотеки~---
такой версии, в которой реализованы все функции, используемые в программе.  С помощью \emph{версионированных интерфейсов}
можно наделить набор новых функций специальной меткой вида \verb|FOO_1.0|, которая в дальнейшем будет учитываться в зависимостях
(т.\,е. появится зависимость на \verb|libfoo.so.1(FOO_1.0)|, если используется какая-либо функция из интерфейса \verb|FOO_1.0|).
Однако следует отметить, что версионированные интерфейсы являются, во-первых, очень хрупкой конструкцией.
Например, версионирование не очень строго учитывается при разрешении символов: загрузчик \verb|ld.so| допускает не только
разрешение неверсионированной ссылки в версионированный символ, но и разрешение версионированной ссылки в неверсионированный
символ (чтобы сохранить возможность переопределения версионированных символов через \verb|LD_PRELOAD|).  Кроме того,
версионированные интерфейсы не должны заполянться постепенно, а должны появляться <<одновременно>> с набором новых функций,
что плохо согласуется с инкрементальной разработкой.  Если же добавлять функции в интерфейс постепенно, то мы возвращаемся
к прежней проблеме: наличие интерфейса оказывается недостаточным для того, чтобы гарантировать наличие нужных функций.
Конечно, можно попытаться запретить использовать <<нестабильные>> версии библиотек с частично заполненными интерфейсами,
но это не решает проблему гарантий на уровне зависимостей.  Для использования промежуточных версий библиотек на самом деле
требуется б\'{о}льшая гранулярность версионирования~--- в пределе, каждый новый символ библиотеки нужно снабжать отдельным интерфейсом
(тогда наличие интерфейса будет напрямую гарантировать наличие символа).

Во-вторых, использование версионированных интерфейсов не получило широкого распространения (например, оно не используется
в библиотеках GNOME и KDE).  Отчасти это связано с тем, что информацию о версионированных интерфейсах нужно поддерживать <<вручную>>,
отчасти~--- с ограниченной совместимостью (версионирование поддерживается только в загрузчике \verb|ld.so| из \verb|glibc|).
В одном российском дистрибутиве мы предприняли попытку самостоятельно поддерживать версионированные интерфейсы в пакетах
с библиотеками.  Однако такой подход приводит к тому, что программы, собранные в одном российском дистрибутиве, перестают
запускаться в других дистрибутивах (т.\,к. требуются отсутствующие версионированные интерфейсы).  Кроме того, как уже отмечено,
поддержка версионированных интерфейсов не может быть полностью автоматизирована, и каждый раз при сборке новой версии пакета
с библиотекой требуется квалифицированная работа по обновлению и проверке.
В дальнейшем мы отказались от использования <<самодельных>> версионированных интерфейсов.

Рассмотренная проблема <<минимальной версии>> не является единственной проблемой, которая приводит к нарушению бинарной совместимости.
Часто авторы библиотек сознательно допускают нарушение обратной совместимости, удаляя устаревшие функции в новых версиях библиотек.
Авторы также могут считать, что они вправе изменять недокументированные функции и т.\,п.  Как бы там ни было, в исследовани,
выполненном в ИПС РАН,\footnote{См. \emph{Автоматизированный анализ обратной совместимости Linux-библиотек} в сборнике
\url{http://docs.altlinux.org/archive/conference/trubezh2010.pdf}} удаление функций и глобальных переменных названо
главной проблемой бинарной совместимости.  Некоторые другие аспекты бинарной совместимости, такие, как изменение типа данных
параметра в языке C++ или добавление спецификатора \verb|static|, тоже связаны с разрешением символов.

Все эти соображения привели к разработке новой модели зависимостей,\footnote{См. \textit{Комплементарное хеширование подмножеств} там же.}
направленной на <<просто совместимость>>, т.\,е. такой модели, в которой напрямую гарантируется наличие нужных функций.  В этой модели
интерфейс, предоставляемый библиотекой, формализуется как множество символов $P$~--- множество функций и глобальных переменных библиотеки;
а требуемя версия библиотеки формализуется как множество библиотечных символов $R$, используемых в программе.  Программа совместима
с библиотекой, если $R\subseteq P$.  Несколько точнее, пусть имеется несколько версий библиотеки с разновидностями интерфейса
$P_0,P_1,\ldots$ и несколько версий программы, в которых используются наборы символов $R_0,R_1,\ldots$  Тогда версия библиотеки $P_i$
совместима с версией программы $R_j$, если $R_j\subseteq P_i$.

\section{Другие методы поиска зависимостей}

\subsection{shebang.req}
\label{shebang-req}

\subsection{files.req}
\label{files-req}

\subsection{symlinks.req}
\label{symlinks-req}

\subsection{cpp.req}
\subsection{pkgconfig.req}
\subsection{pkgconfiglib.req}
\subsection{rpm-build-mono}
\label{rpm-build-mono}

\section{Зависимости \%post-скриптов}

\label{post-script-deps}

\section{Фильтрация зависимостей, weak provides}
\label{filter-deps}

\section{Подпакеты с отладочной информацией}

\label{debuginfo-subpackages}

\section{Проверки во время сборки пакетов}

\label{brp-verify}

\section{Разное}

\subsection{rpm4 vs rpm5}

\subsection{multiarch}

\subsection{компоненты rpm-build}

\subsection{Файлтриггеры}

\end{document}
