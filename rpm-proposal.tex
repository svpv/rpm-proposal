\documentclass[russian,a4paper,12pt,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{fullpage}
\usepackage{url}

\sloppy
\hyphenpenalty=666

\begin{document}
\title{Предложения по развитию\\системы управления пакетами RPM}
\author{Алексей Турбин \url{<at@altlinux.org>}}
\maketitle
\tableofcontents
\pagebreak[4]

\section*{Введение}
Ян Мёрдок (основатель проекта Debian) назвал управление пакетами <<самым
выдающимся достижением, которое Linux привнес в IT-отрасль>>.\footnote{\textit{The
single biggest advancement Linux has brought to the industry.}
\url{http://ianmurdock.com/solaris/how-package-management-changed-everything/}}
Мёрдок отмечает, в частности, возможность унифицированного обновления ПО по сети,
а также модель распределенной разработки, которая стала возможна благодаря разбиению
операционной системы на компоненты.

Нужно заметить, однако, что возможность обновления пакетов по сети
реализуется в виде надстройки (apt, yum) над базовым уровнем управления пакетами
(rpm, deb), тогда как модель распределенной разработки является не столько техническим,
сколько социальным аспектом разработки свободного ПО.  В то же время функции, реализуемые
на базовом уровне управления пакетами, подозрительно похожи на функции архиватора типа tar,
который существовал в UNIX всегда.
Действительно, rpm-пакеты можно рассматривать как <<тарболлы>>, а rpm~--- как
некоторое подобие tar (по крайней мере, в части установки пакетов).  Более того,
в некоторых системах <<тарболл>> и является основным форматом пакетов.  Возникает
вопрос: каковы главные особенности системы управления пакетами на базовом уровне,
делающие её принципиально отличной от архиватора?  Что можно считать
<<достижением>> на базовом уровне?

На первый взгляд, главным отличием rpm от архиватора является возможность обновления и удаления пакетов.
В отличие от обычного архиватора, rpm поддерживает базу пакетов \verb|rpmdb|, в которой хранится информация
об установленных пакетах и о файлах, ассоциированных с пакетами.  При обновлении пакетов эта информация
позволяет корректно выполнить замещение файлов и т.\,п.  Впрочем, нужно понимать, что некоторая сложность,
связанная с корректным замещением файлов, возникает вследствие использования традиционной иерархии файловой
системы, при которой файлы в зависимости от их назначения располагаются в разных системных каталогах.
Некоторые разработчики считают традиционную иерархию файловой системы слишком сложной.
Так, в дистрибутиве GoboLinux выполнена полная реорганизация файловой системы: каждому пакету отводится
собственный подкаталог в системном каталоге \verb|/Programs|.  Это радикально упрощает обновление пакетов,
сводя его к удалению старого каталога и распаковке нового архива.

На наш взгляд, принципальное отличие управления пакетами от <<управления тарболлами>> состоит в другом.
Архиватору безразлично содержимое файлов в архиве, распаковка~--- это его единственная функция; сохранность
байтов~--- это всё, что его в принципе интересует.  В то же время перед rpm стоит более сложная задача:
поддержка операционной системы в целостном, согласованном состоянии.  Фактически, базовый уровень
управления пакетами должен гарантировать работоспособность операционной системы (в той степени,
в которой это вообще возможно) и обеспечивать совместимость установленных компонентов ПО.  Возможность
обновления ПО по сети, отмеченную Мёрдоком, можно интерпретировать именно так~--- как поддержку ОС
в актуальном рабочем состоянии.

Таким образом, можно сказать, что базовый уровень управления пакетами является <<достижением>> настолько,
насколько он \textit{не сводится} к функциям архиватора.  В частности, в какой-то момент система управления
пакетами должна весьма сильно интересоваться содержимым файлов, входящих в пакет, т.\,к. работоспособность
операционной системы и совместимость компонентов ПО могут быть во многих случаях объяснены в терминах
содержимого тех или иных файлов.  Если же не интересоваться содержимым файлов, то гарантировать их согласованную
совместную работу, по-видимому, никак нельзя.

В rpm основным способом описания работоспособности и совместимости пакетов являются \textit{зависимости}.
При сборке пакетов rpm изучает содержимое файлов, входящих в пакет, и формирует зависимости пакета.
Зависимости Requires описывают требования, которые предъявляются к другим пакетам.  Зависимости Provides
в свою очередь описывают <<предоставляемые>> свойства пакета, которые могуть быть <<затребованы>> через
Requires в других пакетах.  Соответственно, в rpm имеются вспомогательные программы \verb|find-requires|
и \verb|find-provides|, которые выполняют поиск Requires и Provides зависимостей.  Эти две программы
составляют основу \textit{подсистемы автоматического поиска зависимостей} (эта подсистема также может быть
использована для автоматического поиска зависимостей типа \verb|Reqires(post)| в \%post-скриптах,
о чем подробнее в разделе \ref{post-script-deps}).  Большая часть данного документа посвящена
усовершенствованию этой подсистемы.  Как будет видно в дальнейшем, многие требования работоспособности
и совместимости пакетов могут быть описаны гораздо более точно (так, в разделе \ref{set-versions} описан
способ компактного представления множества символов, с помощью которого можно в значительной степени
решить проблему т.\,н. <<dll hell>>~--- проблему версионирования и неполной совместимости разделяемых библиотек).

Интересно отметить <<асимметричный>> характер системы управления пакетами на базовом уровне: содержимое
файлов изучается только во время сборки пакетов для формирования зависимостей.  На стадии же установки
rpm руководствуется зависимостями, полученными при сборке; а содержимое файлов его снова не интересует.
В терминах дихотомии Эрика Реймонда\footnote{\textit{Rule of Separation: Separate policy from mechanism;
separate interfaces from engines.} \url{http://www.faqs.org/docs/artu/ch01s06.html}}
можно сказать, что при установке пакетов работает базовый \textit{механизм}, тогда как \textit{политика}
управления пакетами на самом деле осуществляется во время сборки.

Политика сборки пакетов не обязательно должна ограничиваться анализом файлов для формирования зависимостей.
Можно реализовать более агрессивную политику сборки, направленную, во-первых, на автоматическую коррекцию содержимого
пакетов, а во-вторых, на процедуры автоматической верификации, которые должны быть выполнены, чтобы пакет успешно собрался.
Эти процедуры могут выполняться, в частности, на стадии brp (buildroot policy).  Примером коррекции содержимого
пакетов является процедура brp-debuginfo, которая используется для подготовки пакетов с отладочной информацией (см. раздел
\ref{debuginfo-subpackages}).  Некоторые процедуры автоматической верификции рассмотрены в разделе \ref{brp-verify}.

Однако не все проверки стоит выполнять при сборке пакета.  Некоторые проверки
являются специфическими для дистрибутива и поэтому не могут быть частью базовой
политики сборки пакета (например, сюда можно отнести формальное требование указывать
в \%changelog <<официальный>> e-mail адрес, связанный с проектом).  Другие проверки не требуют
доступа к содержимому файлов~--- например, проверка на соответствие FHS (filesystem hierarchy standard).
Другой пример: архитектурно-независимые пакеты (noarch) не должны содержать архитектурно-зависимых путей
(файлов в каталоге \verb|/usr/lib64| и подкаталогах).  Такие проверки можно оформить в виде отдельной программы
типа rpmlint.

Между прочим, последняя проверка является в некотором смысле недостаточной: не только в noarch пакетах не должно быть
архитектурно-зависимых путей, но и вообще при сборке на любой архитектуре должны получаться идентичные noarch пакеты.
Таким образом, выполнение такой проверки потребует синхронной сборки пакета на двух (или более) архитектурах, т.е.
она не может быть реализована на уровне rpm, а только на уровне сборочной системы (если сборочная система синхронизирует
сборку для нескольких архитектур).  В сборочной системе одного российского дистрибутива реализована именно такая~--- достаточно
строгая~--- политика верификации noarch пакетов.

Мы завершаем введение кратким обзором сборочной системы.\footnote{Подробнее см. \textit{Сборочная система git.alt}
в сборнике \url{http://www.altlinux.ru/media/book-thesis-Protva-2008-5.pdf}}  Приоритетной задачей сборочной системы
является автоматическое тестирование и верификация пакетов во время и после сборки, т.\,е. политика сборки, направленная
на поддержку целостности репозитория пакетов (в то время как, например, наличие веб-интерфейса для нас не представляет интереса).
Сборочная система характеризуется относительно высоким процентом отказов в приеме пакетов (при обнаружении дефектов в пакетах).
В то же время сборочная система работает полностью автоматически, и пакеты без дефектов поступают в репозиторий сразу же (проверка
вручную и дополнительное тестирование могут быть организованы перед синхронизацией репозитория на основной публичный сервер).

Политику сборочной системы можно описать в терминах \textit{формальной модели}: поступление новых пакетов моделируется
как переход репозитория из состояния $A_0$ в состояние $A_1$.  При этом, в идеале, в любом состоянии должно быть выполнено
формальное условие, которое можно назвать \textit{инвариантом перехода}: все пакеты должны успешно проходить тестовую пересборку,
и все пакеты должны успешно устанавливаться в базовую среду (basesystem).  В реальности контролировать инвариант перехода
удается лишь частично, т.\,к. тестовая пересборка всех пакетов требует довольно много вычислительных ресурсов.
Как следствие, нереализованной остается принципиально важный компонент сборочной системы~--- \textit{метарепозиторий},
который позволил бы учитывать взаимное влияние между пакетами и, в частности, контролировать изменение свойств пакета
после тестовой пересборки (а не только сам факт пересобираемости).

Интерфейс сборочной системы позволяет формировать \textit{задания} на сборку.  Задание может содержать несколько
пакетов, которые собираются в строгой последовательности (без изменения основного репозитория).  После этого моделируется
переход $A_0\to A_1$ и, если переход разрешен, задание \textit{транзакционно} применяется к репозиторию.  Таким образом,
сборочная система позволяет проводить несовместимые изменения~--- такие, как изменение soname библиотеки~--- при условии
синхронной пересборки (в этом же задании) всех несовместимых/зависимых пакетов.

К недостаткам сборочной системы можно отнести некоторые ограничения на возможность параллельной сборки,
т.\,к. параллельные переходы не моделируются.

\section{Раскрытие макросов в спекфайле}

\section{Оптимизация зависимостей}

\section{Модульная система поиска зависимостей}

\section{Файловые зависимости и процедура find-package}

\section{Зависимости шелл-скриптов}

\section{Сборка perl-пакетов~--- rpm-build-perl}

\section{Зависимости на ELF-библиотеки, set-версии}

\label{set-versions}

\section{Другие методы поиска зависимостей}

\subsection{shebang.req}
\subsection{files.req}
\subsection{symlinks.req}
\subsection{cpp.req}
\subsection{pkgconfig.req}
\subsection{pkgconfiglib.req}

\section{Зависимости \%post-скриптов}

\label{post-script-deps}

\section{Фильтрация зависимостей, weak provides}

\section{Подпакеты с отладочной информацией}

\label{debuginfo-subpackages}

\section{Проверки во время сборки пакетов}

\label{brp-verify}

\section{Разное}

\subsection{rpm4 vs rpm5}

\subsection{multiarch}

\subsection{компоненты rpm-build}

\subsection{Файлтриггеры}

\end{document}
